[{"id":"2d6b2269a15455f29ea7408d5e9ec9fe","title":"AtCoder Beginner Contest 248","content":"AtCoder Beginner Contest 248\n\n\n\n\n\n\n\n\n下载PDF，获得别样的观看体验\nhttps://skynesserblog.oss-cn-hangzhou.aliyuncs.com/Atcoder/AtCoder%20Beginner%20Contest%20248/AtCoder%20Beginner%20Contest%20248/AtCoder-Beginner-Contest-248.pdf\n\nA - Lacked Number题意：\n\n\n\n\n\n\n\n\n\n给出10个数字，输出0~9中未出现的那个数字。\n思路：\n\n\n\n\n\n\n\n\n\n统计数字出现情况即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 2e5+10,M = 2e5+10,INF = 0x3f3f3f3f,mod = 32768;\n\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int cnt[10] = {0};\n    std::string s;\n    std::cin&gt;&gt;s;\n    for(auto c : s)cnt[c-'0']++;\n    for(int i = 0 ; i &lt; 10 ; i++)if(!cnt[i])std::cout&lt;&lt;i;\n    return 0;\n}\nB - Slimes题意：\n\n\n\n\n\n\n\n\n\n给定三个数字,每次操作可以使,输出的最小次数\n思路：\n\n\n\n\n\n\n\n\n\n直接模拟即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 2e5+10,M = 2e5+10,INF = 0x3f3f3f3f,mod = 32768;\n\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    ll a,b,k;\n    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;k;\n    int cnt = 0;\n    while(b &gt; a)cnt++,a *= k;\n    std::cout&lt;&lt;cnt;\n    return 0;\n}\nC - Dice Sum题意：\n\n\n\n\n\n\n\n\n\n现要求找到一个长度为的序列，对于其中的每一个元素，满足如下要求：\n\n\n\n\n\n询问满足要求的序列个数。\n\n思路：\n\n\n\n\n\n\n\n\n\n考虑动态规划\n设有：\n\n\n第一维表示当前序列长度\n第二维表示当前序列的和\n数组的值表示方案数\n\n枚举所有长度以及序列和，进行状态转移即可。\n\n转移方程：for(int i = 1 ; i &lt;= n ; i++)\n        for(int j = 1 ; j &lt;= m ; j++)\n            for(int o = i + j - 1; o &lt;= k ; o++)\n            {\n                dp[i][o] = (dp[i][o] + dp[i-1][o-j])%mod;\n            }\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 60,M = 2e5+10,INF = 0x3f3f3f3f,mod = 998244353;\n\nll dp[N][N*N];\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n,m,k;\n    std::cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n    dp[0][0] = 1;\n    for(int i = 1 ; i &lt;= n ; i++)\n        for(int j = 1 ; j &lt;= m ; j++)\n            for(int o = i + j - 1; o &lt;= k ; o++)\n            {\n                dp[i][o] = (dp[i][o] + dp[i-1][o-j])%mod;\n            }\n    ll sum = 0;\n    for(int i = n ; i&lt;= k ; i++)sum = (sum + dp[n][i])%mod;\n    std::cout&lt;&lt;sum;\n    return 0;\n}\nD - Range Count Query题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为的序列，和个询问，询问格式如下：\n\n给定,要求输出序列中到区间内值为$X的个数。\n\n思路：\n\n\n\n\n\n\n\n\n\n因为，所以我们可以用一个数组，把每一个数字的所有下标分别存起来，然后用二分解决询问即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 2e5+10,M = 2e5+10,INF = 0x3f3f3f3f,mod = 998244353;\n\nstd::vector&lt;int&gt; v[N];\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n,q;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        v[x].push_back(i);\n    }\n    std::cin&gt;&gt;q;\n    while(q--)\n    {\n        int l,r,x;\n        std::cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;\n        auto it1 = std::lower_bound(v[x].begin(),v[x].end(),l);\n        if(it1==v[x].end())\n        {\n            std::cout&lt;&lt;0&lt;&lt;'\\n';\n            continue;\n        }\n        auto it2 = std::upper_bound(v[x].begin(),v[x].end(),r);\n        if(it2==v[x].begin())\n        {\n            std::cout&lt;&lt;0&lt;&lt;'\\n';\n            continue;\n        }\n        it2--;\n        std::cout&lt;&lt;(it2-it1+1)&lt;&lt;'\\n';\n    }\n    return 0;\n}\nE - K-colinear Line题意：\n\n\n\n\n\n\n\n\n\n在坐标平面内存在个点，每个点的坐标为，询问存在多少条不同的直线，穿过至少个点。\n思路：\n\n\n\n\n\n\n\n\n\n因为两点可以确定一条直线，而且点数，所以可以进行如下处理：\n\n\n两两枚举所有的点\n在确定完一条直线后，枚举所有的点判断这条直线穿过了多少点\n\n三个点在一条直线上，显然有\n\n将所有满足条件的直线统计出来即可。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 310,M = 2e5+10,INF = 0x3f3f3f3f,mod = 998244353;\nstruct Node{\n    ll x,y;\n}a[N];\nbool book[N][N];\n\nbool OK(Node x,Node y,Node z)\n{\n    return (z.y-y.y)*(z.x-x.x)==(z.y-x.y)*(z.x-y.x);\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int ans = 0;\n    int n,k;\n    std::cin&gt;&gt;n&gt;&gt;k;\n    if(k==1)\n    {\n        std::cout&lt;&lt;\"Infinity\";\n        return 0;\n    }\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i].x&gt;&gt;a[i].y;\n    for(int i = 1 ; i &lt; n ; i++)\n        for(int j = i + 1 ; j &lt;= n ; j++)\n            if(!book[i][j])\n            {\n                int cnt = 2;\n                std::vector&lt;int&gt; b;\n                for(int o = 1 ; o &lt;= n ; o++)\n                {\n                    if(o == i || o == j)continue;\n                    if(OK(a[i],a[j],a[o]))\n                    {\n                        cnt++;\n                        b.push_back(o);\n                    }\n                }\n                b.push_back(i);\n                b.push_back(j);\n                for(auto x : b)\n                    for(auto y : b)book[x][y] = true;\n                if(cnt &gt;= k)ans++;\n            }\n    std::cout&lt;&lt;ans;\n    return 0;\n}\nF - Keep Connect题意：&gt;\n\n\n\n\n\n\n\n\n\n给出这样的一个连通图，对于每一个，输出删除条边并且仍然保持连通性的方案数。\n思路：\n\n\n\n\n\n\n\n\n\n考虑动态规划\n设有:\n\n\n表示前组点\n表示删除的边数\n第三维记录的是第组点之间的连通性(第组的两个点当前能否连通)\n数组值表示方案数\n\n我们用三个值来代表三条边，表示这条边是否删除。\n\n\n\n\n\n\n\n\n\n\n那么当第组点是不连通的时候，显然是要保证两条边都相连，否则整张图必然失去连通性。\n当第组点是连通的时候，我们只需要保证有一条边是连通的即可，如果三边中相连了至少两条边，那么就可以保证第组点是连通的。\n\n\n有转移方程if(!k)\n{\n    if(!a||!b)continue;\n    dp[i+1][j+1-c][c] = (dp[i+1][j+1-dp[i][j][k])%Mod;\n}\nelse\n{\n    if(!a&amp;&amp;!b)continue;\n    dp[i+1][j+3-a-b-c][(a+b+c)&gt;=2] = [j+3-a-b-c][(a+b+c)&gt;=2] + dp[i%Mod;\n}时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 3010,M = 2e5+10,INF = 0x3f3f3f3f,mod = 998244353;\n\nll dp[N][N][2];\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    dp[1][0][1] = dp[1][1][0] = 1;\n    int n;\n    ll Mod;\n    std::cin&gt;&gt;n&gt;&gt;Mod;\n    for(int i = 1 ; i &lt; n ; i++)\n        for(int j = 0 ; j &lt;= n ; j++)\n            for(int k = 0 ; k &lt; 2 ; k++)\n                if(dp[i][j][k])\n                    for(int a = 0 ; a &lt; 2 ; a++)\n                        for(int b = 0 ; b &lt; 2 ; b++)\n                            for(int c = 0 ; c &lt; 2 ; c++)\n                            {\n                               if(!k)\n                               {\n                                   if(!a||!b)continue;\n                                   dp[i+1][j+1-c][c] = (dp[i+1][j+1-c][c] + dp[i][j][k])%Mod;\n                               }\n                               else\n                               {\n                                   if(!a&amp;&amp;!b)continue;\n                                   dp[i+1][j+3-a-b-c][(a+b+c)&gt;=2] = (dp[i+1][j+3-a-b-c][(a+b+c)&gt;=2] + dp[i][j][k])%Mod;\n                               }\n                            }\n    for(int i = 1 ; i &lt; n ; i++)std::cout&lt;&lt;dp[n][i][1]&lt;&lt;' ';\n    return 0;\n}\nEx - Beautiful Subsequences题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为的全排列,询问满足如下条件的区间个数：\n\n\n\n\n思路：\n\n\n\n\n\n\n\n\n\n线段树+单调栈：\n\n\n线段树：我们先固定一个,然后尝试去维护一个序列，这个序列中的第个点记录的值为，如果这个值,那么这个点所代表的区间就是一个合法区间，此外，因为这个序列是全排列，所以不难发现不会是负数。我们用线段树去维护这一段区间，区间内记录的最小值，并且记录下的点的个数。然后就可以通过根节点的信息推知答案。\n单调栈：我们可以通过单调栈动态的确定区间最值，确定完最值以后通过线段树区间修改即可。\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 150000,M = 2e5+10,INF = 0x3f3f3f3f,mod = 998244353;\nstruct Node{\n    int l,r;\n    int val,add,cnt[4];\n}tr[N*4];\nint w[N],k;\n\nvoid pushup(int u)\n{\n    tr[u].val = std::min(tr[u&lt;&lt;1].val,tr[u&lt;&lt;1|1].val);\n    for(int i = 0 ; i &lt;= k ; i++)\n    {\n        tr[u].cnt[i] = 0;\n        int temp = tr[u].val - tr[u&lt;&lt;1].val + i;\n        if(temp &gt;= 0)tr[u].cnt[i] += tr[u&lt;&lt;1].cnt[temp];\n        temp = tr[u].val - tr[u&lt;&lt;1|1].val + i;\n        if(temp &gt;= 0)tr[u].cnt[i] += tr[u&lt;&lt;1|1].cnt[temp];\n    }\n}\n\nvoid pushdown(int u)\n{\n    if(tr[u].add)\n    {\n        tr[u&lt;&lt;1].val += tr[u].add;\n        tr[u&lt;&lt;1|1].val += tr[u].add;\n        tr[u&lt;&lt;1].add += tr[u].add;\n        tr[u&lt;&lt;1|1].add += tr[u].add;\n        tr[u].add = 0;\n    }\n}\n\nvoid build(int u,int l,int r)\n{\n    if(l==r)\n    {\n        tr[u] = {l,r};\n        tr[u].cnt[0] = 1;\n        tr[u].val = INF;\n    }\n    else\n    {\n        tr[u] = {l,r};\n        int mid = l + r &gt;&gt; 1;\n        build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r);\n    }\n}\n\nvoid modify(int u,int l,int r,int v)\n{\n    if(l &gt; r)return;\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)\n    {\n        tr[u].val += v;\n        tr[u].add += v;\n    }\n    else\n    {\n        pushdown(u);\n        int mid = tr[u].l + tr[u].r &gt;&gt; 1;\n        if(l &lt;= mid)modify(u&lt;&lt;1,l,r,v);\n        if(r &gt; mid)modify(u&lt;&lt;1|1,l,r,v);\n        pushup(u);\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n;\n    std::cin&gt;&gt;n&gt;&gt;k;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;w[i];\n    build(1,1,n);\n    std::stack&lt;std::pair&lt;std::pair&lt;int,int&gt;,int&gt;&gt; stk1,stk2;\n    ll ans = 0;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        modify(1,i,i,-INF);\n        modify(1,1,i-1,-1);\n        int x1 = i,x2 = i;\n        while(!stk1.empty())\n        {\n            if(w[i] &lt; stk1.top().second)\n            {\n                modify(1,stk1.top().first.first,stk1.top().first.second,stk1.top().second);\n                x1 = stk1.top().first.first;\n                stk1.pop();\n            }\n            else break;\n        }\n        while(!stk2.empty())\n        {\n            if(w[i] &gt; stk2.top().second)\n            {\n                modify(1,stk2.top().first.first,stk2.top().first.second,-stk2.top().second);\n                x2 = stk2.top().first.first;\n                stk2.pop();\n            }\n            else break;\n        }\n        stk1.push({{x1,i},w[i]});\n        stk2.push({{x2,i},w[i]});\n        modify(1,x1,i,-w[i]);\n        modify(1,x2,i,w[i]);\n        for(int c = 0 ; c &lt;= k ; c++)\n            if(tr[1].val + c &lt;= k)ans += tr[1].cnt[c];\n    }\n    std::cout&lt;&lt;ans;\n    return 0;\n}\n\n此外，大家也可以看dls的视频讲解，在这里附上链接https://www.bilibili.com/video/BV1v44y1G7qj\n \n","slug":"AtCoder-Beginner-Contest-248","date":"2022-04-17T06:36:25.000Z","categories_index":"Atcoder","tags_index":"题解","author_index":"skynesser"},{"id":"f5cdf4952ba5a694914b8f81e24f50f6","title":"hexo教程--教你半个小时搭建自己的博客","content":"\n前言\n\n\n\n\n\n\n\n\n\nhexo是一个相当好用的博客框架，仅仅用短短的几十分钟就可以上手。\n本文会着重于hexo的使用，在开始之前，请确保安装好git和node.js，涉及到这个部分的教程在网上都很多，在这里不会额外介绍。\n如果想快速看到效果，请务必按照下面的步骤执行。\n\n博客地址:http://skynesser.github.io/\n本地搭建这个部分会教你让你在本地上运行你的博客，以下命令均在控制台上执行。\n安装hexo通过下面的代码检查node.js是否安装成功\n\n\n\n\n\n\n\n\n\nnode -v\nnpm -v\n 安装hexo\n\n\n\n\n\n\n\n\n\nnpm install -g hexo-cli\n \n初始化hexo\n\n\n\n\n\n\n\n\nhexo init blogname\n这里的blogname是你要建立博客文件夹的名字。\n这里就会出现一个blogname的文件夹然后文件夹的内部就会出现一些文件。然后进入到这个blogname的目录下，执行下面这个命令。\n\n\n\n\n\n\n\n\n\nnpm install\n执行完以后，就可以在本地运行了，执行下面两行命令，就可以看见你搭建的博客。\n在本地运行\n\n\n\n\n\n\n\n\nhexo g\nhexo server\n这就是默认的博客。\n特别需要注意的命令\n\n\n\n\n\n\n\n\n需要注意的是，上面的命令在后续博客使用过程中会频繁使用的只有\n\nhexo g\n这个命令或生产静态文件，在你写完一份你的博客之后，如果想要在本地上看到改变，必须要使用这个命令。换言之，就是该命令生成了博客的html等文件。\n\nhexo server\n\n\n\n\n\n\n\n\n可以让你在本地上查看你的博客，在后续部署到github的过程中，强烈建议写完博客后先在本地查看无误后，再更新到github上。\n\n\n总结起来就是在你写完博客以后，先使用hexo g命令，再使用hexo server命令即可在本地上查看你的博客。\n\n\n部署githubgithub上创建仓库\n\n\n\n\n\n\n\n\n\n\n这里的username就是你的github里的用户名。\n配置文件\n\n找到这个位置，修改如下：deploy:\n  type: git\n  repo: https://github.com/username/username.github.io.git\n  branch: master将username处改为你的github用户名即可。\n完成部署先下载命令如下：\n\n\n\n\n\n\n\n\n\nnpm install hexo-deployer-git —save\n下载安装好后，执行下面三行命令即可完成部署：\n\n\n\n\n\n\n\n\n\nhexo clean\nhexo g\nhexo d\n需要特别注意的命令\n\n\n\n\n\n\n\n\n与上面本地运行类似的是，我们在修改完博客后，使用下面两个命令即可实现部署。\n\nhexo g\nhexo d\n\n部署完后就可以在https://username.github.io访问你的博客。\n最后关于发布文章文章都存在与source的_post目录下，想要删除文章直接将其移除即可，新建文章可以执行以下命令：\n\n\n\n\n\n\n\n\n\nhexo new articlename\n  \n更多的命令可以查询官方文档：https://hexo.io/zh-cn/index.html\n","slug":"hexo教程-教你半个小时搭建自己的博客","date":"2022-04-14T06:24:44.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"98b45b9456085a7bd89a44573d5e4235","title":"BFS--1429胜利大逃亡(续)","content":"1429 胜利大逃亡(续)\n\n题意：\n\n\n\n\n\n\n\n\n\n\n思路：\n\n\n\n\n\n\n\n\n\n本题的重点在于标记数组，除了基本的坐标以外，在同一位置是否有某个钥匙显然会影响结果，所以这样一来，我们就要为每个钥匙拥有与否多开一维数组，这样总共就会有12维的标记数组。但这样显然是不方便的，我们就可以用二进制数来代替，这就是状态压缩。例子：\n\n有钥匙:0000000001有钥匙:0000000010有钥匙和:0000000011\n\nAC代码：\n\n\n\n\n\n\n\n\n\n判断某个钥匙是否拥有temp.state&amp;(1&lt;&lt;(a[tx][ty]-'A')\n捡到某个钥匙temp.state|(1&lt;&lt;(a[tx][ty]-'a'))\n#include&lt;bits/stdc++.h&gt;\n\nconst int N = 25,M = 2e5+10,INF = 0x3f3f3f3f;\nstruct Node{\n    int x,y,state,step;\n};\n\nint n,m,t,start_x,start_y,end_x,end_y;\nint ne[4][2] = {0,1,1,0,0,-1,-1,0};\nchar a[N][N];\nbool book[N][N][1024];\n\nvoid bfs()\n{\n    memset(book,false,sizeof book);\n    std::queue&lt;Node&gt; que;\n    que.push({start_x,start_y,0,0});\n    book[start_x][start_y][0] = true;\n    while(!que.empty())\n    {\n        auto temp = que.front();\n        que.pop();\n        if(temp.step &gt;= t)continue;\n        if(temp.x == end_x &amp;&amp; temp.y == end_y)\n        {\n            std::cout&lt;&lt;temp.step&lt;&lt;'\\n';\n            return;\n        }\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.x + ne[i][0];\n            int ty = temp.y + ne[i][1];\n            if(tx&lt;1||ty&lt;1||tx&gt;n||ty&gt;m||a[tx][ty]=='*')continue;\n            if(a[tx][ty]&gt;='A'&amp;&amp;a[tx][ty]&lt;='J')\n            {\n                if((temp.state&amp;(1&lt;&lt;(a[tx][ty]-'A'))))\n                {\n                    if(!book[tx][ty][temp.state])\n                    {\n                        book[tx][ty][temp.state] = true;\n                        que.push({tx,ty,temp.state,temp.step+1});\n                    }\n                }\n            }\n            else if(a[tx][ty]&gt;='a'&amp;&amp;a[tx][ty]&lt;='j')\n            {\n                int state = temp.state|(1&lt;&lt;(a[tx][ty]-'a'));\n                if(!book[tx][ty][state])\n                {\n                    book[tx][ty][state] = true;\n                    que.push({tx,ty,state,temp.step+1});\n                }\n            }\n            else\n            {\n                if(!book[tx][ty][temp.state])\n                {\n                    book[tx][ty][temp.state] = true;\n                    que.push({tx,ty,temp.state,temp.step+1});\n                }\n            }\n        }\n    }\n    std::cout&lt;&lt;-1&lt;&lt;'\\n';\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    while(std::cin&gt;&gt;n&gt;&gt;m&gt;&gt;t)\n    {\n        for(int i = 1 ; i &lt;= n ; i++)\n        {\n            std::cin&gt;&gt;(a[i]+1);\n            for(int j = 1 ; j &lt;= m ; j++)\n            {\n                if(a[i][j]=='@')start_x = i,start_y = j;\n                else if(a[i][j]=='^')end_x = i,end_y = j;\n            }\n        }\n        bfs();\n    }\n    return 0;\n}\n","slug":"BFS-1429胜利大逃亡-续","date":"2022-04-14T05:06:49.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"907654ea5663a4368dcac6ec50f50e0b","title":"BFS--1254推箱子","content":"1254推箱子\n\n题意：\n\n\n\n\n\n\n\n\n\n\n思路：\n\n\n\n\n\n\n\n\n\n箱子的移动按照正常的BFS拓展即可。重点在于判断搬运工能否把箱子往某个方向推：\n\n\n显然，箱子需要移动到，搬运工需要移动到\n箱子所在的位置对搬运工来说是无法跨越的障碍。\n搬运工能否到达目标地并不能简单的判断，需要再用BFS来判断可行性(总的来说，出现了BFS套BFS)。\n\n此外，标记数组也应该得到修改，因为搬运工在不同的位置，会对上述可行性的判断产生影响，所以标记数组除了箱子的位置，还有搬运工的位置，标记数组需要有四维。\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\nconst int N = 10,M = 2e5+10,INF = 0x3f3f3f3f;\nstruct Node{\n    int x,y,px,py,step;\n};\nint n,m,start_x,start_y,end_x,end_y,p_x,p_y;\nint a[N][N];\nint ne[4][2] = {1,0,0,1,-1,0,0,-1};\nbool book[N][N][N][N],vis[N][N];\n\nbool OK(int x1,int y1,int x2,int y2)\n{\n    memset(vis,false,sizeof vis);\n    std::queue&lt;std::pair&lt;int,int&gt;&gt; que;\n    vis[x1][y1] = true;\n    que.push({x1,y1});\n    while(!que.empty())\n    {\n        auto temp = que.front();\n        que.pop();\n        if(temp.first == x2 &amp;&amp; temp.second == y2)return true;\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.first + ne[i][0];\n            int ty = temp.second + ne[i][1];\n            if(tx&lt;1||ty&lt;1||tx&gt;n||ty&gt;m||a[tx][ty]==1||vis[tx][ty])continue;\n            vis[tx][ty] = true;\n            que.push({tx,ty});\n        }\n    }\n    return false;\n}\n\nvoid bfs()\n{\n    std::queue&lt;Node&gt; que;\n    que.push({start_x,start_y,p_x,p_y,0});\n    book[start_x][start_y][p_x][p_y] = true;\n    while(!que.empty())\n    {\n        auto temp = que.front();\n        que.pop();\n        if(temp.x == end_x &amp;&amp; temp.y == end_y)\n        {\n            std::cout&lt;&lt;temp.step&lt;&lt;'\\n';\n            return;\n        }\n        a[temp.x][temp.y] = 1;\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.x + ne[i][0];\n            int ty = temp.y + ne[i][1];\n            if(tx&lt;1||ty&lt;1||tx&gt;n||ty&gt;m||a[tx][ty]==1||book[tx][ty][temp.x][temp.y])continue;\n            if(!OK(temp.px,temp.py,temp.x-ne[i][0],temp.y-ne[i][1]))continue;\n            que.push({tx,ty,temp.x,temp.y,temp.step+1});\n            book[tx][ty][temp.x][temp.y] = true;\n        }\n        a[temp.x][temp.y] = 0;\n    }\n    std::cout&lt;&lt;-1&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        memset(book,false,sizeof book);\n        std::cin&gt;&gt;n&gt;&gt;m;\n        for(int i = 1 ; i &lt;= n ; i++)\n            for(int j = 1 ; j &lt;= m ; j++)\n            {\n                std::cin&gt;&gt;a[i][j];\n                if(a[i][j]==2) start_x = i,start_y = j;\n                else if(a[i][j]==3)end_x = i,end_y = j;\n                else if(a[i][j]==4)p_x = i,p_y = j;\n            }\n        bfs();\n    }\n    return 0;\n}\n","slug":"BFS-1254推箱子","date":"2022-04-14T05:06:25.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"e8cb84f974ea3f0e5a5c5a284c7fbc6b","title":"BFS--1495非常可乐","content":"1495 非常可乐\n\n题目：\n\n\n\n\n\n\n\n\n\n\n思路：\n\n\n\n\n\n\n\n\n\n抽象BFS，把三个杯子的水量抽象成的一个三维坐标，并按照题目要求修改拓展方式，在此基础上BFS即可(可以理解为在三维空间的BFS)。拓展方式：\n\n\n对于一个坐标一定要转移到类似于或者等，其实就是模拟倒水过程，倒水过程要么倒水杯为空或者被倒水杯已满。\n\n还是多补充一点：只要能抽象出表示状态的点和表示状态转移方式的边就可以搜索答案，这也是DFS和BFS用处广泛而强大的原因之一，经过抽象，可以解决很多的问题。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n$O(SNM)$\nAC代码：\n\n\n\n\n\n\n\n\n\n事实上这题需要处理的地方还是有一些的，如果强行取模拟代码会又臭又长，而且还不容易调试，下面给出我的一份WA血泪教训(想偷懒结果寄了):\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e2+5,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y,z,step;\n}que[N*N*N*3];\n\nint a,b,c;\nbool book[N][N][N];\n\nvoid bfs()\n{\n    if(a&amp;1)\n    {\n        std::cout&lt;&lt;\"NO\\n\";\n        return;\n    }\n    int head = 0,tail = -1;\n    que[++tail] = {a,0,0};\n    book[a][0][0] = true;\n    while(tail &gt;= head)\n    {\n        auto temp = que[head++];\n        if((temp.x==a/2)+(temp.y==a/2)+(temp.z==a/2)==2)\n        {\n            std::cout&lt;&lt;temp.step&lt;&lt;'\\n';\n            return;\n        }\n        if(temp.x)\n        {\n            if(temp.x &gt;= b - temp.y)\n            {\n                if(!book[temp.x-(b-temp.y)][b][temp.z])\n                {\n                    book[temp.x-(b-temp.y)][b][temp.z] = true;\n                    que[++tail] = {temp.x-(b-temp.y),b,temp.z,temp.step+1};\n                }\n            }\n            else\n            {\n                if(!book[0][temp.y+temp.x][temp.z])\n                {\n                    book[0][temp.x+temp.y][temp.z] = true;\n                    que[++tail] = {0,temp.x+temp.y,temp.z,temp.step+1};\n                }\n            }\n            if(temp.x &gt;= c - temp.z)\n            {\n                if(!book[temp.x-(c-temp.z)][temp.y][c])\n                {\n                    book[temp.x-(c-temp.z)][temp.y][c] = true;\n                    que[++tail] = {temp.x-(c-temp.z),temp.y,c,temp.step+1};\n                }\n            }\n            else\n            {\n                if(!book[0][temp.y][temp.z+temp.x])\n                {\n                    book[0][temp.y][temp.z+temp.x] = true;\n                    que[++tail] = {0,temp.y,temp.z+temp.x,temp.step+1};\n                }\n            }\n        }\n        if(temp.y)\n        {\n            if(temp.y &gt;= a - temp.x)\n            {\n                if(!book[a][temp.y-(a-temp.x)][temp.z])\n                {\n                    book[a][temp.y-(a-temp.x)][temp.z] = true;\n                    que[++tail] = {a,temp.y-(a-temp.x),temp.z,temp.step+1};\n                }\n            }\n            else\n            {\n                if(!book[temp.x+temp.y][0][temp.z])\n                {\n                    book[temp.x+temp.y][0][temp.z] = true;\n                    que[++tail] = {temp.x+temp.y,0,temp.z,temp.step+1};\n                }\n            }\n            if(temp.y &gt;= c - temp.z)\n            {\n                if(!book[temp.x][temp.y-(c-temp.z)][c])\n                {\n                    book[temp.x][temp.y-(c-temp.z)][c] = true;\n                    que[++tail] = {temp.x,temp.y-(c-temp.z),c,temp.step+1};\n                }\n            }\n            else\n            {\n                if(!book[temp.x][0][temp.z+temp.y])\n                {\n                    book[temp.x][0][temp.z+temp.y] = true;\n                    que[++tail] = {temp.x,0,temp.z+temp.y,temp.step+1};\n                }\n            }\n        }\n        if(temp.z)\n        {\n            if(temp.z &gt;= a - temp.x)\n            {\n                if(!book[a][temp.y][temp.z-(a-temp.x)])\n                {\n                    book[a][temp.y][temp.z-(a-temp.x)] = true;\n                    que[++tail] = {a,temp.y,temp.z-(a-temp.x),temp.step+1};\n                }\n            }\n            else\n            {\n                if(!book[temp.x+temp.z][temp.y][0])\n                {\n                    book[temp.x+temp.z][temp.y][0] = true;\n                    que[++tail] = {temp.x+temp.z,temp.y,0,temp.step+1};\n                }\n            }\n            if(temp.z &gt;= b - temp.y)\n            {\n                if(!book[temp.x][b][temp.z-(b - temp.y)])\n                {\n                    book[temp.x][b][temp.z-(b - temp.y)] = true;\n                    que[++tail] = {temp.x,b,temp.z-(b - temp.y),temp.step+1};\n                }\n            }\n            else\n            {\n                if(!book[temp.x][temp.y+temp.z][0])\n                {\n                    book[temp.x][temp.y+temp.z][0] = true;\n                    que[++tail] = {temp.x,temp.z+temp.y,0,temp.step+1};\n                }\n            }\n        }\n    }\n    std::cout&lt;&lt;\"NO\\n\";\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    while(std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)\n    {\n        if(a==0&amp;&amp;b==0&amp;&amp;c==0)break;\n        for(int i = 1 ; i &lt;= a ; i++)\n            for(int j = 1 ; j &lt;= b ; j++)\n                for(int k = 1 ; k &lt;= c ; k++)book[i][j][k] = false;\n        bfs();\n    }\n}\n\n\n\n\n\n\n\n\n\n我们可以发现上面对于情况的讨论类似的代码是非常多的，所以我加了点处理，把所有情况用一份代码,缩短了代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e2+10,M = 2e5+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int b[3],step;\n}que[N*N*N];\n\nint a[3],pw[3];\nbool book[N*N*N];\n\nvoid bfs()\n{\n    if(a[0]&amp;1)\n    {\n        std::cout&lt;&lt;\"NO\\n\";\n        return;\n    }\n    int tail = -1,head = 0;\n    que[++tail] = {a[0],0,0,0};\n    pw[0] = 1,pw[1] = 101,pw[2] = 101*101;\n    book[a[0]] = true;\n    while(tail &gt;= head)\n    {\n        auto temp = que[head++];\n        if((temp.b[0]==a[0]/2)+(temp.b[1]==a[0]/2)+(temp.b[2]==a[0]/2)==2)\n        {\n            std::cout&lt;&lt;temp.step&lt;&lt;'\\n';\n            return;\n        }\n        for(int i = 0 ; i &lt;= 2 ; i++)\n        {\n            for(int j = 1 ; j &lt;= 2 ; j++)\n            {\n                int x = i,y = (i+j)%3,z = (i+j+(j==1?1:-1))%3;\n                if(!temp.b[x])continue;\n                if(temp.b[x] &gt;= (a[y]-temp.b[y]))\n                {\n                    int state = (temp.b[x]-(a[y]-temp.b[y]))*pw[x]+a[y]*pw[y]+temp.b[z]*pw[z];\n                    if(!book[state])\n                    {\n                        book[state] = true;\n                        tail++;\n                        que[tail].b[x] = temp.b[x]-(a[y]-temp.b[y]);\n                        que[tail].b[y] = a[y];\n                        que[tail].b[z] = temp.b[z];\n                        que[tail].step = temp.step + 1;\n                    }\n                }\n                else\n                {\n                    int state = (temp.b[y]+temp.b[x])*pw[y]+temp.b[z]*pw[z];\n                    if(!book[state])\n                    {\n                        book[state] = true;\n                        tail++;\n                        que[tail].b[x] = 0;\n                        que[tail].b[y] = (temp.b[y]+temp.b[x]);\n                        que[tail].b[z] = temp.b[z];\n                        que[tail].step = temp.step + 1;\n                    }\n                }\n            }\n        }\n    }\n    std::cout&lt;&lt;\"NO\\n\";\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    while(std::cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2])\n    {\n        if(a[0]==0||a[1]==0||a[2]==0)break;\n        memset(book,false,sizeof book);\n        bfs();\n    }\n}\n","slug":"BFS-1495非常可乐","date":"2022-04-14T05:06:14.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"eeb246d9896a7a0782afd0a59c27d35d","title":"BFS--胜利大逃亡","content":"1253 胜利大逃亡\n题意：\n\n\n\n\n\n\n\n\n\n\n思路：\n\n\n\n\n\n\n\n\n\n将BFS原来二维的部分改成三维，其余部分均不变即可。注：\n\n用cin读入要关流，否则会超时\n\n读入优化代码：\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(nullptr);\nstd::cout.tie(nullptr);\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 60,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y,z,step;\n}que[N*N*N];\n\nint a,b,c,t;\nbool g[N][N][N],book[N][N][N];\nint ne[6][3] = {{1,0,0},{-1,0,0},{0,1,0},{0,-1,0},{0,0,1},{0,0,-1}};\n\nbool OK(int x,int y,int z)\n{\n    if(x&lt;1||y&lt;1||z&lt;1||x&gt;a||y&gt;b||z&gt;c||book[x][y][z]||g[x][y][z])return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int tail = -1,head = 0;\n    que[++tail] = {1,1,1};\n    book[1][1][1] = true;\n    while(tail &gt;= head)\n    {\n        auto temp = que[head++];\n        if(temp.x == a &amp;&amp; temp.y == b &amp;&amp; temp.z == c)\n        {\n            std::cout&lt;&lt;temp.step&lt;&lt;'\\n';\n            return;\n        }\n        if(temp.step&gt;t)continue;\n        for(int i = 0 ; i &lt; 6 ; i++)\n        {\n            int tx = temp.x + ne[i][0];\n            int ty = temp.y + ne[i][1];\n            int tz = temp.z + ne[i][2];\n            if(!OK(tx,ty,tz))continue;\n            book[tx][ty][tz] = true;\n            que[++tail] = {tx,ty,tz,temp.step+1};\n        }\n    }\n    std::cout&lt;&lt;-1&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;t;\n        for(int i = 1 ; i &lt;= a ; i++)\n            for(int j = 1 ; j &lt;= b ; j++)\n                for(int k = 1 ; k &lt;= c ; k++)std::cin&gt;&gt;g[i][j][k],book[i][j][k] = false;\n        bfs();\n    }\n}\n","slug":"BFS-胜利大逃亡","date":"2022-04-14T05:05:43.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"4642bf8fd86a906e3377d06b9ee7f52a","title":"BFS--1242Rescue","content":"1242 Rescue\n题意：\n\n\n\n\n\n\n\n\n\n解释如下：\n\n：终点：起点路You can't use 'macro parameter character #' in math mode{\\color{red}#：障碍}敌人需要花一个单位时间打败\n输出从起点到终点的最小步数，如果不存在路径，输出”Poor ANGEL has to stay in the prison all his life.”。\n\n思路：\n\n\n\n\n\n\n\n\n\n我们在拓展时，如果一个点是敌人，则会导致我们需要花2步才能走到这个点，这将导致 BFS 每次出队的不一定是队列中步数最小的点，所以我们要用一个优先队列代替队列，使得每次出队的都是最小步数的点这一性质。\n特别的，关于重载：\nstruct Node{\n    int x,y,step;\n    bool operator&lt;(const Node &amp;a)const\n    {\n        return a.step &lt; step;\n    }\n};\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e2+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y,step;\n    bool operator&lt;(const Node &amp;a)const\n    {\n        return a.step &lt; step;\n    }\n};\n\nchar a[N][N];\nint n,m,start_x,start_y,end_x,end_y;\nint ne[4][2] = {0,1,1,0,0,-1,-1,0};\nbool book[N][N];\n\nbool OK(int x,int y)\n{\n    if(x&lt;1||y&lt;1||x&gt;n||y&gt;m||book[x][y]||a[x][y]=='#')return false;\n    return true;\n}\n\nvoid bfs()\n{\n    memset(book,false,sizeof book);\n    std::priority_queue&lt;Node&gt; que;\n    que.push({start_x,start_y,0});\n    book[start_x][start_y] = true;\n    while(!que.empty())\n    {\n        auto temp = que.top();\n        que.pop();\n        if(temp.x == end_x &amp;&amp; temp.y == end_y)\n        {\n            std::cout&lt;&lt;temp.step&lt;&lt;'\\n';\n            return;\n        }\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.x + ne[i][0];\n            int ty = temp.y + ne[i][1];\n            if(!OK(tx,ty))continue;\n            if(a[tx][ty]=='x')book[tx][ty] = true,que.push({tx,ty,temp.step+2});\n            else book[tx][ty] = true,que.push({tx,ty,temp.step+1});\n        }\n    }\n    std::cout&lt;&lt;\"Poor ANGEL has to stay in the prison all his life.\\n\";\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    while(std::cin&gt;&gt;n&gt;&gt;m)\n    {\n        for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;(a[i]+1);\n        for(int i = 1 ; i &lt;= n ; i++)\n            for(int j = 1 ; j &lt;= m ; j++)\n                if(a[i][j]=='r')start_x = i,start_y = j;\n                else if(a[i][j]=='a')end_x = i,end_y = j;\n        bfs();\n    }\n    return 0;\n}\n\n","slug":"BFS-1242Rescue","date":"2022-04-14T05:05:30.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"fc4a684f7b377b87f7fe86a8b5c2db69","title":"BFS--1181变形课","content":"1181 变形课\n题意：\n\n\n\n\n\n\n\n\n\n\n\n思路：把题目抽象成图，抽象方法如下:\n\n起点：b终点：m路径：对于一个字符串，表示从到存在一条路径。根据如上规则建图bfs即可。\n\nAC代码：#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 30,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint que[N];\nbool g[N][N];\nbool book[N];\n\nbool bfs()\n{\n    memset(book,false,sizeof book);\n    int head = 0,tail = -1;\n    que[++tail] = 'b' - 'a';\n    book['b' - 'a'] = true;\n    while(tail&gt;=head)\n    {\n        int temp = que[head++];\n        if(temp=='m'-'a')return true;\n        for(int i = 0 ; i &lt; 26 ; i++)\n        {\n            if(!book[i] &amp;&amp; g[temp][i])\n            {\n                que[++tail] = i;\n                book[i] = true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    std::string s;\n    while(std::cin&gt;&gt;s)\n    {\n        if(s[0]=='0') std::cout&lt;&lt;(bfs() ? \"Yes.\\n\" : \"No.\\n\"),memset(g,false,sizeof g);\n        else g[s[0]-'a'][s[s.size()-1]-'a'] = true;\n    }\n    return 0;\n}\n","slug":"BFS-1181变形课","date":"2022-04-14T05:05:14.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"87d1f3817eb5ea98b0e200ea76c187c4","title":"BFS--1180诡异的楼梯","content":"1180诡异的楼梯\n题意：\n\n\n\n\n\n\n\n\n\n中文题面，题意也比较直接，直接上原题。\n\n思路：在楼梯不能通过的时候，原地等待一个单位时间就可以了。\n\n注：本题还有一种优先队列的做法，我们可以认为通过一个当前无法通过的楼梯，所花费的时间是2个单位时间(加上等待的时间)，但是这样做会使得队列中每次出队的不一定是步数最小的点，所以要用优先队列维护(其实没什么必要这样做，正常的bfs就可以解决)。\n\nAC代码：\n\n不使用优先队列：\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 30,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y,step;\n}que[N*N*2];\nchar a[N][N];\nbool book[N][N];\nint n,m,start_x,start_y,end_x,end_y;\nint ne[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\n\nbool OK(int x,int y)\n{\n    if(x&lt;1||y&lt;1||x&gt;n||y&gt;m||a[x][y]=='*'||book[x][y])return false;\n    return true;\n}\n\nint bfs()\n{\n    memset(book,false,sizeof book);\n    int head = 0,tail = -1;\n    que[++tail] = {start_x,start_y,0};\n    book[start_x][start_y] = true;\n    while(tail&gt;=head)\n    {\n        auto temp = que[head++];\n        if(temp.x == end_x &amp;&amp; temp.y == end_y)return temp.step;\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.x + ne[i][0];\n            int ty = temp.y + ne[i][1];\n            if(!OK(tx,ty))continue;\n            if(a[tx][ty]=='.'||a[tx][ty]=='T')book[tx][ty] = true,que[++tail] = {tx,ty,temp.step+1};\n            else\n            {\n                if(a[tx][ty]=='|' &amp;&amp; temp.step%2==0 || a[tx][ty]=='-' &amp;&amp; temp.step%2==1)\n                {\n                    if(i &lt; 2)//i &lt; 2 表示上下移动\n                    {\n                        tx += ne[i][0];\n                        if(OK(tx,ty))book[tx][ty] = true,que[++tail] = {tx,ty,temp.step+1};\n                    }\n                    else  que[++tail] = {temp.x,temp.y,temp.step+1};\n                }\n                else\n                {\n                    if(i &gt;= 2)\n                    {\n                        ty += ne[i][1];\n                        if(OK(tx,ty))book[tx][ty] = true,que[++tail] = {tx,ty,temp.step+1};\n                    }\n                    else que[++tail] = {temp.x,temp.y,temp.step+1};\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    while(std::cin&gt;&gt;n&gt;&gt;m)\n    {\n        for(int i = 1 ; i &lt;= n ; i++)\n            for(int j = 1 ; j &lt;= m ; j++)\n            {\n                std::cin&gt;&gt;a[i][j];\n                if(a[i][j]=='S')start_x = i,start_y = j;\n                else if(a[i][j]=='T')end_x = i,end_y = j;\n            }\n        std::cout&lt;&lt;bfs()&lt;&lt;'\\n';\n    }\n    return 0;\n}\n\n使用优先队列\n\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;iomanip&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\n#define rep(i,n) for(int i = 1 ; i &lt;= n ; i++)\n#define endl '\\n'\nusing namespace std;\nconst int MAXN = 30;\ntypedef long long ll;\nstruct node{\n    int x,y,step;\n    friend bool operator &lt;(struct node x,struct node y)\n    {\n        return x.step&gt;y.step;\n    }\n};\n\n\n\npriority_queue&lt;struct node&gt; que;\nchar g[MAXN][MAXN];\nbool book[MAXN][MAXN];\nint head,tail,n,m;\nint startx,starty,endx,endy;\nint ne[4][2] = {0,1,1,0,0,-1,-1,0};\n\nint bfs()\n{\n    rep(i,n)\n    rep(j,m)\n    book[i][j] = false;\n    head = tail = 0;\n    book[startx][starty] = true;\n    que.push({startx,starty,0});\n    while(tail&gt;=head)\n    {\n        auto temp = que.top();\n        que.pop();\n//        cout&lt;&lt;temp.x&lt;&lt;\" \"&lt;&lt;temp.y&lt;&lt;\" \"&lt;&lt;temp.step&lt;&lt;endl;\n        if(temp.x==endx&amp;&amp;temp.y==endy)\n            return temp.step;\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.x+ne[i][0];\n            int ty = temp.y+ne[i][1];\n            if(tx&lt;1||ty&lt;1||tx&gt;n||ty&gt;m||book[tx][ty]||g[tx][ty]=='*')continue;\n            if(g[tx][ty]=='|'&amp;&amp;!(temp.step&amp;1)||g[tx][ty]=='-'&amp;&amp;temp.step&amp;1)//奇数上下\n            {\n                if(i&amp;1)\n                {\n                    tx+=ne[i][0];\n                    ty+=ne[i][1];\n                    if(book[tx][ty])continue;\n                    book[tx][ty] = true;\n                    que.push({tx,ty,temp.step+1});\n                }\n                else\n                {\n                    tx+=ne[i][0];\n                    ty+=ne[i][1];\n                    if(book[tx][ty])continue;\n                    book[tx][ty] = true;\n                    que.push({tx,ty,temp.step+2});\n                }\n            }\n            else if(g[tx][ty]=='|'&amp;&amp;temp.step&amp;1||g[tx][ty]=='-'&amp;&amp;!(temp.step&amp;1))\n            {\n                if(i&amp;1)\n                {\n                    tx+=ne[i][0];\n                    ty+=ne[i][1];\n                    if(book[tx][ty])continue;\n                    book[tx][ty] = true;\n                    que.push({tx,ty,temp.step+2});\n                }\n                else\n                {\n                    tx+=ne[i][0];\n                    ty+=ne[i][1];\n                    if(book[tx][ty])continue;\n                    book[tx][ty] = true;\n                    que.push({tx,ty,temp.step+1});\n                }\n            }\n            else\n            {\n                if(book[tx][ty])continue;\n                book[tx][ty] = true;\n                que.push({tx,ty,temp.step+1});\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n//    cin.tie(0);\n//    cout.tie(0);\n    while(cin&gt;&gt;n&gt;&gt;m)\n    {\n        rep(i,n)\n        rep(j,m)\n        {\n            cin &gt;&gt; g[i][j];\n            if(g[i][j]=='S')\n            {\n                startx = i;\n                starty = j;\n            }\n            if(g[i][j]=='T')\n            {\n                endx = i;\n                endy = j;\n            }\n        }\n        cout &lt;&lt; bfs()&lt;&lt;endl;\n    }\n    return 0;\n}\n","slug":"BFS-1180诡异的楼梯","date":"2022-04-14T05:04:47.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"2e4ec95259d8f5d717fa4f2ca765d07a","title":"BFS--1175连连看","content":"1175连连看\n@[toc]题意：\n\n\n\n\n\n\n\n\n\n给出一个的棋盘，玩一个类似于连连看的游戏。\n\n1 2 3 40 0 0 04 3 2 1\n：空格其他：不同的棋子给定棋盘以后，给定起点和终点，要求从起点走到终点，方向转折的次数不能超过2次。\n\n思路：\n\n\n\n\n\n\n\n\n\n这题的限制不再是步数，而是转折次数，这就注定了我们不能和正常的bfs一样拓展。那么该如何拓展呢，既然是以转折次数为限制，我们就一次性把一条直线上可以拓展的点全部拓展，具体见下图。\n\n1 2 3 40 0 0 04 3 2 1数字为转折次数，起点特殊记录为-1。起点为，终点为\n每次都往四个方向进行直线拓展。拓展部分代码示例如下：\n\nfor(int i = 0 ; i &lt; 4 ; i++)\n{\n    int tx = temp.x + ne[i][0];\n    int ty = temp.y + ne[i][1];\n    while(OK(tx,ty))\n    {\n        que[++tail] = {tx,ty,temp.step+1};\n        book[tx][ty] = true;\n        tx += ne[i][0];\n        ty += ne[i][1];\n    }\n}    \n时间复杂度：\n\n\n\n\n\n\n\n\n\n$O(nmq)$\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e3+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y,step;\n}que[N*N];\nint a[N][N];\nbool book[N][N];\nint ne[4][2] = {0,1,1,0,0,-1,-1,0};\nint n,m,start_x,start_y,end_x,end_y;\n\n\nbool OK(int x,int y)\n{\n    if(x==end_x&amp;&amp;y==end_y)return true;\n    if(x &lt; 1||y &lt; 1||x &gt; n||y &gt; m||book[x][y]||a[x][y])return false;\n    return true;\n}\n\nvoid bfs()\n{\n    for(int i = 1 ; i &lt;= n ; i++)\n        for(int j = 1 ; j &lt;= m ; j++)book[i][j] = false;\n    int head = 0,tail = -1;\n    std::cin&gt;&gt;start_x&gt;&gt;start_y&gt;&gt;end_x&gt;&gt;end_y;\n    if(a[start_x][start_y]!=a[end_x][end_y]||a[start_x][start_y]==0||a[end_x][end_y]==0)\n    {\n        std::cout&lt;&lt;\"NO\\n\";\n        return;\n    }\n    que[++tail] = {start_x,start_y,-1};\n    book[start_x][start_y] = true;\n    while(tail&gt;=head)\n    {\n        auto temp = que[head++];\n        if(temp.x == end_x &amp;&amp; temp.y == end_y)\n        {\n            std::cout&lt;&lt;\"YES\\n\";\n            return;\n        }\n        if(temp.step==2)continue;\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.x + ne[i][0];\n            int ty = temp.y + ne[i][1];\n            while(OK(tx,ty))\n            {\n                que[++tail] = {tx,ty,temp.step+1};\n                book[tx][ty] = true;\n                tx += ne[i][0];\n                ty += ne[i][1];\n            }\n        }\n    }\n    std::cout&lt;&lt;\"NO\\n\";\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    while(std::cin&gt;&gt;n&gt;&gt;m)\n    {\n        if(n==0&amp;&amp;m==0)break;\n        for(int i = 1 ; i &lt;= n ; i++)\n            for(int j = 1 ; j &lt;= m ; j++)std::cin&gt;&gt;a[i][j];\n        int q;\n        std::cin&gt;&gt;q;\n        while(q--)\n        {\n            bfs();\n        }\n    }\n    return 0;\n}\n\n","slug":"BFS-1175连连看","date":"2022-04-14T05:04:31.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"cf6e09e51125ac3f1f40b26cf31e9a4d","title":"BFS--1072 Nightmare","content":"1072 Nightmare\n题意：\n\n\n\n\n\n\n\n\n\n小明被困在一个迷宫如下中：1.小明每次可以花一个单位时间往上下左右的某个方向移动一格。2.小明身上有一个炸弹，在第6个单位时间就会爆炸，在第6个单位时间走到终点或者刷新炸弹时间是无效的。\n\n举例如下：2 1 1 0 1 1 1 01 0 4 1 1 0 4 11 0 0 0 0 0 0 11 1 1 4 1 1 1 3障碍平路起点终点可以刷新炸弹时间\n\n思路：\n\n\n\n\n\n\n\n\n\n只需要在bfs的基础上修改标记数组即可：\n\nbfs为了避免重复搜索，一般将某个坐标定义为一个状态：一般的，如果我们搜索过，我们下次再次搜索到这个点时将不会把这个点再次加入队列中。\n但是这题中，我们的状态应该多加一个走到该点时的炸弹时间：\n\n\n\n\n\n\n\n\n\n即我们认为当前炸弹在第个单位时间，当前炸弹在第个单位时间等是不同的状态，所以我们在炸弹时间不同的情况下，一个点可能可以重复入队。\n不妨举一个显然的例子：2 1 1 1 41 0 0 0 11 0 4 1 11 0 1 0 01 1 1 1 3\n\n标记数组处理如下：\nbool book[N][N]-&gt;bool book[N][N][7]\n时间复杂度:\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 20,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y,step,time;\n}que[N*N*6];\nint g[N][N];\nint ne[4][2] = {0,1,1,0,-1,0,0,-1};\nbool book[N][N][7];\nint n,m,start_x,start_y,end_x,end_y;\n\nbool OK(int x,int y,int t)\n{\n    if(x&lt;1||y&lt;1||x&gt;n||y&gt;m||g[x][y]==0||book[x][y][t])return false;\n    return true;\n}\n\nint bfs()\n{\n    int tail = -1,head = 0;\n    que[++tail] = {start_x,start_y,0,0};\n    book[start_x][start_y][0] = true;\n    while(tail&gt;=head)\n    {\n        auto temp = que[head++];\n        if(temp.x==end_x&amp;&amp;temp.y==end_y)return temp.step;\n        if(temp.time==5)continue;//炸弹时间在5其实已经无法拓展\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = ne[i][0] + temp.x;\n            int ty = ne[i][1] + temp.y;\n            if(g[tx][ty]==4)\n            {\n                if(OK(tx,ty,0))\n                    que[++tail] = {tx,ty,temp.step+1,0},book[tx][ty][0] = true;\n            }\n            else\n            {\n                if(OK(tx,ty,temp.time+1))\n                    que[++tail] = {tx,ty,temp.step+1,temp.time+1},book[tx][ty][temp.time+1] = true;\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        memset(book,false,sizeof book);\n        std::cin&gt;&gt;n&gt;&gt;m;\n        for(int i = 1 ; i &lt;= n ; i++)\n        {\n            for(int j = 1 ; j &lt;= m ; j++)\n            {\n                std::cin&gt;&gt;g[i][j];\n                if(g[i][j]==2)\n                {\n                    start_x = i,start_y = j;\n                }\n                else if(g[i][j]==3)\n                {\n                    end_x = i,end_y = j;\n                }\n            }\n        }\n        std::cout&lt;&lt;bfs()&lt;&lt;'\\n';\n    }\n    return 0;\n}\n\n\n\n\n","slug":"BFS-1072-Nightmare","date":"2022-04-14T05:04:12.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"bd5b7856161209228b064ee3a7d6843f","title":"0x01位运算--起床困难综合症","content":"0x01位运算——起床困难综合症\n\n思路分析\n\n\n\n\n\n\n\n\n位运算的特点之一就是二进制下运算不进位。因此在可以任意选择的情况下，参与位运算的各个位(bit)是无关的。\n而每一个的初始取值只有0和1两种情况，所以我们只需要枚举每一位，比较初始取值0和1情况下，经过n个防御门后得到的值，在0和1这两种情况下取答案较大的即可。\n\n\n\n\n\n\n\n\n\n\n\n\n\n同时,因为的取值是有范围限制的，所以我们在最终大小相同的情况下，保证尽可能小，即在初始值0和1经过n个防御们后得到值相同时，我们会优先使用0。\n\n时间复杂度\n代码实现\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 1e5+10,M = N,INF = 0x3f3f3f3f,P = 998244353;\n\nint n,x;\nstd::pair&lt;std::string,int&gt; PSI[N];\n\nint cal(int bit,int val)\n{\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x = PSI[i].second&gt;&gt;bit &amp; 1;\n        if(PSI[i].first==\"AND\")val &amp;= x;\n        else if(PSI[i].first==\"OR\")val |= x;\n        else val ^= x;\n    }\n    return val;\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin&gt;&gt;n&gt;&gt;x;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        std::cin&gt;&gt;PSI[i].first&gt;&gt;PSI[i].second;\n    }\n    int res = 0,val = 0;\\\\val表示最后的取值x，res表示最大值(答案)\n    for(int bit = 29 ; bit &gt;= 0 ; bit--)\n    {\n        int ans1 = cal(bit,1);\n        int ans0 = cal(bit,0);\n        if((1 &lt;&lt; bit) + val &lt;= x &amp;&amp; ans0 &lt; ans1)\n            val += 1 &lt;&lt; bit,res += 1 &lt;&lt; bit;\n        else\n            res += ans0 &lt;&lt; bit;\n    }\n    std::cout&lt;&lt;res;\n    return 0;\n}\n\n题目：起床困难综合症\n\n","slug":"0x01位运算-起床困难综合症","date":"2022-04-14T05:00:21.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"5e6fa880a2b85943c805a5daeb5a1a2c","title":"0x01位运算--最短Hamilton路径","content":"0x01位运算——最短Hamilton路径\n\n说明\n\n\n\n\n\n\n\n\n本题的正解——状态压缩dp，我们将在0x56节详细介绍\n\n思路分析\n\n\n\n\n\n\n\n\n\n我们可以使用一个**n维的bool数组**记录下某时刻经过了哪些点，未经过哪些点，而这里的**n维的bool数组**，可以用一个n位的二进制数代替。\n在这个二进制数中，第i位为1则代表这个点已经被拜访过。\n\n用表示当前经过了那些点(用 i 表示),现在在 j 点的最短距离。状态转移方程(不做详解)：^\n\n时间复杂度\n\n\n\n\n\n\n\n\n\n\n\n代码实现\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 20,M = N * N,INF = 0x3f3f3f3f,P = 998244353;\n\nint f[1&lt;&lt;N][N];\nint w[N][N];\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 0 ; i &lt; n ; i++)\n    {\n        for(int j = 0 ; j &lt; n ; j++)\n        {\n            std::cin&gt;&gt;w[i][j];\n        }\n    }\n    memset(f,0x3f,sizeof f);\n    f[1][0] = 0;\n    for(int i = 1 ; i &lt; 1 &lt;&lt; n ; i++)\n        for(int j = 0 ; j &lt; n ; j++) if(i &gt;&gt; j &amp; 1)\n            for(int k = 0 ; k &lt; n ; k++)if((i ^ 1 &lt;&lt; j) &gt;&gt; k &amp; 1)\n                f[i][j] = std::min(f[i][j],f[i ^ 1 &lt;&lt; j][k] + w[k][j]);\n    std::cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1];\n    return 0;\n}\n\n题目：最短Hamilton路径\n\n","slug":"0x01位运算-最短Hamilton路径","date":"2022-04-14T04:59:38.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"97612da9b20c890887f4d716902dc0f2","title":"0x01位运算--64位整数乘法","content":"0x01 位运算——64位整数乘法\n\n问题简析\n\n\n\n\n\n\n\n\nC++内置的最高整数类型是64位，所以显然不能通过直接运算得到答案，我们需要一些特殊的处理方法，在这里提供两种方法。\n\n\n\n思路一\n\n\n\n\n\n\n\n\n\n\n类似于快速幂的思想，把b拆分成k位二进制。$b=C_{k-1}2^{k-1}+C_{k-2}2^{k-2}…+C_{0}2^{0}。ab=C_{k-1}2^{k-1}a+C_{k-2}2^{k-2}a…+C_{0}2^{0}a。若算出ab^{i-1}mod~p，则计算(ab^{i-1})2mod~p的过程中不会超过210^{18}，long ~long可以胜任。$\n\n时间复杂度分析分解出的项数为时间复杂度\n代码实现\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 1e5+10,M = N,INF = 0x3f3f3f3f,P = 998244353;\n\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    ll a,b,p;\n    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n    ll res = 0;\n    for(; b ; b &gt;&gt;= 1)\n    {\n        if(b&amp;1)res = (res + a)%p;\n        a = a * 2 % p;\n    }\n    std::cout&lt;&lt;res;\n    return 0;\n}\n\n思路二\n\n\n\n\n\n\n\n\n$利用ab ~mod~p=ab-\\left \\lfloor ab/p \\right \\rfloorp，\\left \\lfloor  \\right \\rfloor为向下取整首先，假设a&lt;p,b&lt;p,那么ab/p下取整之后一定也小于p，我们可以使用浮点数完成中间计算。long~double的浮点数有效数字在1819位之间，可以胜任。ab 和\\left \\lfloor ab/p \\right \\rfloorp可能会很大,但是易知它们的差值一定在0p-1之间。因为p的范围在long~long以内，所以只需要关心ab 和\\left \\lfloor ab/p \\right \\rfloor*p在long~long范围内的位，更高的位一定是相同的。$\n\n\n\n时间复杂度分析\n\n\n\n\n\n\n\n\n\n\n\n代码实现\n\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 1e5+10,M = N,INF = 0x3f3f3f3f,P = 998244353;\n\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    ll a,b,p;\n    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n    a %= p,b %= p;\n    ll c = (long double)a * b / p;\n    ll res = a * b - c * p;\n    if(res &lt; 0)res += p;\n    else if(res &gt;= p)res -= p;\n    std::cout&lt;&lt;res;\n    return 0;\n}\n\n注意点\n\n\n为什么a和b要mod p？ 因为我们需要保证范围在long long内\n为什么用别的浮点数类型(double)会错？ 因为double的有效位数过小，在乘p以后导致错误 例子：0.002  10000和0.0018  10000显然不同 精度足够以后： 0.0018  10000 和0.001811  10000不会影响\n为什么最后要有这一段代码？\n\nif(res &lt; 0)res += p;\nelse if(res &gt;= p)res -= p;\n因为在第一行对a和b mod p后，由模的性质可以知道最后答案可能会与原来的答案产生p的差值。\n\n题目：64位整数乘法\n\n","slug":"0x01位运算-64位整数乘法","date":"2022-04-14T04:58:43.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"2fe208e266b9d06ce4fcbff1033f1615","title":"0x01位运算--a^b","content":"0x01位运算——a^b\n题目：\n思路分析\n\n\n\n\n\n\n\n\n\n如果在二进制下有位每一位为可以将分解为：$b=C_{k-1}2^{k-1}+C_{k-2}2^{k-2}+…+C_{0}*2^{0}因为2^{k-1}=(2^{k-2})^{2},所以很容易用递推求出每一个乘积项$\n\n时间复杂度分析\n\n\n\n\n\n\n\n\n\n，所以这样的项不会超过个时间复杂度：\n\n代码实现\n\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 3e2+10,M = N * N,INF = 0x3f3f3f3f,P = 998244353;\n\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    int a,b,p;\n    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n    int res = 1;\n    while(b)\n    {\n        if(b&amp;1)res = (ll)res * a % p;\n        b &gt;&gt;= 1;\n        a = (ll)a * a % p;\n    }\n    std::cout&lt;&lt;res%p;\n    return 0;\n}\n\n注意点\n\n\n\n\n\n\n\n\n1.中间计算过程会爆int，所以必须把其中一个数强制转换成long long参与运算2.在while循环外也要对最终结果res取模，避免出现b=0未取模的情况\n\n题目链接a^b\n\n","slug":"0x01位运算-a-b","date":"2022-04-14T04:57:50.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"e27ecc703f2c8f1506aebea43aaa01a7","title":"0x01——位运算","content":"基础知识及二进制常见用法\n前言\n\n\n\n\n\n\n\n\n\n\nbit是度量信息的单位，包含0和1两种状态。计算机的各种运算最后无不归结位一个个bit的变化。熟练掌握并利用位运算，能够帮助我们理解程序运行中的种种表现，提高程序循行的时空效率，降低编程复杂度。\n\n运算符优先级\n\n\n\n\n\n\n\n\n\n\n从左到右优先级依次降低| 加减 |移位 | 比较大小|位与|异或|位或||—|—|—|—|—|—||+，- |&lt;&lt;,&gt;&gt;|&lt;,&gt;==,!=|&amp;|xor(C++^)| | |\n\n位与memset\n\n我们都知道，memset可以以字节为单位初始化变量或者数组，这里有几个特&gt;别的数字：\n\n0x3F3F3F3F 1061109567-&gt; 0x7F7F7F7F 2147483647\n0xFFFFFFFF -1\n\n观察这几个数字，我们会发现0x3F3F3F3F是个很有用的数字，原因如下：\n\n可以直接用memset初始化\n0x3F3F3F3F的两倍不会超过int的最大范围\n这个数足够大\n\n这也是常常使用INF = 0x3F3F3F3F的原因memset(a,0x3f,sizeof a);\n\n移位运算\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&gt;&gt;\n&lt;&lt;\n\n\n\n\n即除以2向下取整\n\n\n\n\n\n例题：\n\na^b\n64位整数乘法\n\n\n二进制状态压缩\n\n\n\n\n\n\n\n\n\n\n二进制状态压缩，是指将一个长度为的数组用一个位的二进制整数表示并储存的方法。利用下列位运算操作可以实现原数组中对应下标的存取。|操作|运算||—|—||取出整数n在二进制表示下的第k位|||取出整数n在二进制表示下的第0~k-1位(后k位)|||把整数n在二进制表示下的第k位取反|||对整数n在二进制表示下的第k位赋值1||||对整数n在二进制表示下的第k位赋值0|~|\n例题：\n\n最短Hamilton路径2.起床困难综合症\n\n\n位的其他应用\n\n\n成对变换\n\n\n\n\n\n\n\n\n\n\n通过计算可以发现，对于非负整数\n\n当为偶数时，等于\n当为奇数时，等于\n\n因此，与，与，与关于运算构成成对变换\n这一性质经常用于图论邻接表的储存。\n在具有无向边（双向边）的图中把一对正反方向的边分别储存在邻接表数组的与 位置（为偶数），就可以通过的运算获得与当前边反向的边的储存位置。详细应用我们将在讲解邻接表时(第0x13节)给出。\n\nlowbit运算\n\n\n\n\n\n\n\n\n\nlowbit运算定义非负整数在二进制表示下 最低位的及其后边所有的 构成的数值。例如 n = 10 的二进制表示为 ，则。下面我们来推导的公式。\n设的第位是，第 ~ 位都是。 为了实现运算，先把取反，此时第  ~ 位都是。 在令，此时因为进位，第位变为， 第 ~ 位都是。 而且的第到最高位恰好与原来相反，所以 ~仅有第位为， 其余位都是，而在补码表示下~因此： ~\n操作可以配合Hash(0x14节)可以找到整数二进制表示下所有是1的位。 此外，运算也是树状数组(0x42节)中的一个基本运算。\n\n\n","slug":"0x01——位运算","date":"2022-04-13T13:14:40.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"f65394965aa072446681bba60362a87b","title":"最小二乘法","content":"最小二乘法从高数分数预测开始\n\n\n\n\n\n\n\n\n给一组数据如下：|认真听课的时间|最后的考试分数||-|-||20|40||25|60||30|75||35|80||40|85||45|100|我们假设认真听课的时间为，最后的考试分数为。并且假设两者间的关系为一个线性函数：那么我们要怎么通过上面的数据得到一个尽可能精确的模型呢。\n最小二乘法在问题中的使用如何判断我们寻找的函数的精确程度设函数的计算值与真实值之间的差值为:\n如何减小误差：\n\n\n\n\n\n\n\n\n\n我们会发现是一个关于和的二元函数，而且对于某个变量来说，它们之间是二次函数关系那么我们要寻找的点应该就是上图中的极小值点。我们可以通过如下公式向极小值点逼近：$k=k-\\alpha\\frac{\\partial loss }{\\partial k}其中\\alpha为一个常数，又称为学习率，如果我们直接让减去相应的偏导数，可能减小的数会过大，使得k越来越远离极小值点。我们对b$也进行相同的处理，这一整个过程即*最小二乘法。 \n在代码中的实现(python)x_list = [20, 25, 30, 35, 40, 45]\ny_list = [40, 60, 75, 80, 85, 100]\n\na = 0.0005# 学习率\n\nk = 1# 给k和b随便赋一个初值\nb = 1\n# for(int i = 0 ;  i &lt; 3 ; i++)\nfor epoch in range(100000):# 训练的次数\n    loss = 0\n    loss_k = 0# k的导数\n    loss_b = 0# b的导数\n    for i in range(3):\n        loss += (k * x_list[i] + b - y_list[i]) * (k * x_list[i] + b - y_list[i])\n        loss_k += 2 * x_list[i] * (k * x_list[i] + b - y_list[i])\n        loss_b += 2 * (k * x_list[i] + b - y_list[i])\n\n    k -= a * loss_k\n    b -= a * loss_b\n\n    if epoch % 100 == 0:\n        print(\"loss = %f,loss_b = %f,loss_k = %f,k = %f,b = %f\" % (loss, loss_b, loss_k, k, b))\n效果图：\n","slug":"最小二乘法","date":"2022-04-13T13:12:41.000Z","categories_index":"","tags_index":"","author_index":"skynesser"},{"id":"0e8f626ea0dbc25b970b50c6d6ca6667","title":"Codeforces Round 781 (Div. 2)","content":"\n\nA. GCD vs LCM题意：\n\n\n\n\n\n\n\n\n\n给定数n，找到a,b,c,d四个数满足下列条件：\n\n1.2.\n\n思路：\n\n\n\n\n\n\n\n\n\n取特殊情况，令即可。即构造\n时间复杂度：\n\n\n\n\n\n\n\n\n\n所需时间与输入规模无关:\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\nconst int N = 2e2+10,M = 2e5+10,INF = 0x3f3f3f3f;\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    std::cout&lt;&lt;1&lt;&lt;' '&lt;&lt;n-3&lt;&lt;1&lt;&lt;' '&lt;&lt;1&lt;&lt;'\\n';\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\nB. Array Cloning Technique题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为n的初始数组副本，你可以进行以下两种操作：\n\n\n选择任意一个数组副本，将其复制出一个新的数组副本。\n选择两个数组副本，交换它们的两个元素。\n\n询问将其中任意一个数组副本的全部元素变相同的最少操作次数。\n\n思路：\n\n\n\n\n\n\n\n\n\n\n首先，我们贪心的选择第一个数组副本作为目标，将这个数组的全部元素变成相同。\n然后，我们记录下初始数组副本中的最大相同数字出现次数,那么将其他所有元素变成相同的交换(操作1)次数显然是。\n接着我们计算复制数组副本的次数(操作2)，我们不难发现每次复制并交换结束后，相同数的个数都会翻倍，所以我们通过这种方式找到最小复制次数即可。\n\n最后，将操作1和操作2的次数相加即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n统计相同数字的最大出现次数中使用了map来完成，所以时间复杂度为：\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\nconst int N = 2e2+10,M = 2e5+10,INF = 0x3f3f3f3f;\n\nvoid solve()\n{\n    int n;\n    int max = 0;\n    std::cin&gt;&gt;n;\n    std::map&lt;int,int&gt; mp;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        mp[x]++;\n        if(mp[x] &gt; max)max = mp[x];\n    }\n    int res = 0,cnt = n - max;\n    if(cnt==0)std::cout&lt;&lt;0&lt;&lt;'\\n';\n    else\n    {\n        for(;max &lt; n;max &lt;&lt;= 1)res++;\n        res += cnt;\n        std::cout&lt;&lt;res&lt;&lt;'\\n';\n    }\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\nC. Tree Infection题意：\n\n\n\n\n\n\n\n\n\n给定一棵树，现在要去感染这棵树的全部节点，我们可以在每个单位时间内执行以下两种操作(同时进行)：\n\n\n对于所有的节点，如果他的某个孩子节点被感染，那么可以感染一个其它健康的孩子节点。2.任意选择一个健康的节点，并感染它。\n\n询问将整棵树感染的最少时间。 \n\n思路：\n\n\n\n\n\n\n\n\n\n首先，我们可以发现，感染传播(操作1)只会在一个个”孩子群体”中进行，实际上感染与树并没有太大的关系，我们完全可以把这一个个”孩子群体”取出来。还是举个例子(第一个案例)：\n\n71 1 1 2 2 4很显然，这里的”群体”有这些：{1},{2,3,4},{5,6},{7}\n我们可以先把所有的群体找出来，然后采用贪心策略，从数量大的群体开始感染，采用如下判断方法：\n\n\n\n\n\n\n\n\n\n\n我们从大到小感染所有”群体”(依次对所有”群体”使用操作1一次，然后让它们内部传播)，我们记录下完成上述操作后所有群体还剩下的未感染个数(如果已经全部感染则不用管)。\n如果此时还有剩余节点未被感染，我们让它们内部传播，并手动感染剩余节点最多的”群体”。\n\n即在贪心后模拟感染的过程(实现上可能还是有点复杂了)。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n使用了map和优先队列，总时间复杂度：\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\nconst int N = 2e2+10,M = 2e5+10,INF = 0x3f3f3f3f;\n\nvoid solve()\n{\n    int n,t = 0;\n    std::cin&gt;&gt;n;\n    std::priority_queue&lt;int&gt; que;\n    std::map&lt;int,int&gt; mp;\n    mp[0] = 1;\n    for(int i = 1 ; i &lt; n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        mp[x]++;\n    }\n    std::vector&lt;int&gt; num;\n    for(auto map : mp)num.push_back(map.second);//从大到小排序\"群体\"\n    std::sort(num.begin(),num.end());\n    for(auto val : num)//第一步\n    {\n        if(val - 1 - t &gt; 0)que.push(val - 1 - t);\n        t++;\n    }\n    int res = 0;\n    while(true)\n    {\n        if(que.empty()||que.top() - res &lt;= 0)break;//第二步\n        que.push(que.top()-1);\n        que.pop();\n        res++;\n    }\n    std::cout&lt;&lt;res+t&lt;&lt;'\\n';\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\nD. GCD Guess题意：\n\n\n\n\n\n\n\n\n\n交互题：先要猜测一个整数x的大小，你可以按照以下规则询问最多30次：\n\n给出数字和，返回\n\n思路：\n\n\n\n\n\n\n\n\n\n30次的询问次数，我们应该尝试从位的角度取解决。那么我们怎么知道每一位取0还是1呢，按照如下方法：\n\n\n假设我们已知\n那么的~位应该全是0\n我们可以用是否等于来判断位取0还是1。\n若等于，则取1，若不等，则取0。\n此时询问的，而询问数应该大于0，所以我们询问。\n若等于，则取0，若不等，则取1。\n（这个转换是为了凑出a和b）,所以询问为。\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n我们每次询问可以确定数的某一位：\nAC代码：\n#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 2e2+10,M = 2e5+10,INF = 0x3f3f3f3f;\n\nint query(int x,int y)\n{\n    std::cout&lt;&lt;\"? \"&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;std::endl;\n    int res;\n    std::cin&gt;&gt;res;\n    return res;\n}\n\nvoid solve()\n{\n    int ans = 0;\n    for(int i = 1 ; i &lt;= 30 ; i++)\n    {\n        int res = query((1&lt;&lt;i-1)-ans,(1&lt;&lt;i)+(1&lt;&lt;i-1)-ans);\n        if(res != (1&lt;&lt;i-1))ans += (1&lt;&lt;i-1);\n    }\n    std::cout&lt;&lt;\"! \"&lt;&lt;ans&lt;&lt;std::endl;\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\nE. MinimizOR题意：\n\n\n\n\n\n\n\n\n\n给定长度为n的数组，定义花费为，现在给出q个询问：\n\n给出整数和，找出区间内的最小花费。\n\n思路：\n\n\n\n\n\n\n\n\n\n本题最重要的是证明一个性质：\n\n如果区间内的最大数(即最大数不超过k位),那么答案一定在个区间最小数内按位或产生。证明如下：\n\n对,只有0和1两个数，显然成立。现在我们将设结论对成立，我们尝试证明对也成立。分类讨论：\n\n若位全是1，那么答案必然出现在之前已经选择的个数中，而且此时选择的个最小数与之前应该是一致的。\n若位0的个数大于等于2，那么答案必然出现在之前已经选择的k+1个数中，而且此时选择的个最小数与之前应该是一致的。\n若位0的个数恰好等于1，应该取1，所以答案还是出现在之前选择的个数中，但是此时选择的个最小数与之前不一定一致，因为最坏情况就是之前个数位全是1，而此时位是0的一个数会取代其中的一个数，所以我们这个时候要多取一个数，取个最小数即可。\n\n通过以上说明，我们证明结论：\n\n\n\n\n\n\n\n\n\n如果区间内的最大数(即最大数不超过k位),那么答案一定在个区间最小数内按位或产生\n\n现在的任务就是找到区间最小数，这个可以用线段树完成。此外，因为的范围并不会很大，所以我们每次并不会真的求出它，我们每次都假定它在边界最大值，所以每次最多找到31个最小数。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n这题的常数会特别大，因为每次询问都需要查找最多31次。\nAC代码：\n#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 1e5+10,M = 2e5+10,INF = (1ll&lt;&lt;31)-1;\nstruct Node{\n    int l,r,v,id;\n}tr[N*4];\nint w[N];\n\nvoid pushup(int u)\n{\n    tr[u].v = std::min(tr[u&lt;&lt;1].v,tr[u&lt;&lt;1|1].v);\n    if(tr[u&lt;&lt;1].v &lt; tr[u&lt;&lt;1|1].v)tr[u].id = tr[u&lt;&lt;1].id;\n    else tr[u].id = tr[u&lt;&lt;1|1].id;\n}\n\nvoid build(int u,int l,int r)\n{\n    if(l==r)\n    {\n        tr[u] = {l,r,w[r],r};\n    }\n    else\n    {\n        tr[u] = {l,r};\n        int mid = l + r &gt;&gt; 1;\n        build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r);\n        pushup(u);\n    }\n}\n\nstd::pair&lt;int,int&gt; query(int u,int l,int r)\n{\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)\n    {\n        return std::make_pair(tr[u].v,tr[u].id);\n    }\n    else\n    {\n        int mid = tr[u].l + tr[u].r &gt;&gt; 1;\n        std::pair&lt;int,int&gt; ans = {INF,INF};\n        if(l &lt;= mid)ans = std::min(ans,query(u&lt;&lt;1,l,r));\n        if(r &gt; mid)ans = std::min(ans,query(u&lt;&lt;1|1,l,r));\n        return ans;\n    }\n}\n\nvoid modify(int u,int x,int v)\n{\n    if(tr[u].l==x&amp;&amp;tr[u].r==x)\n    {\n        tr[u].v = v;\n    }\n    else\n    {\n        int mid = tr[u].l + tr[u].r &gt;&gt; 1;\n        if(x &lt;= mid)modify(u&lt;&lt;1,x,v);\n        else modify(u&lt;&lt;1|1,x,v);\n        pushup(u);\n    }\n}\n\nvoid solve()\n{\n    int n,q;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;w[i];\n    build(1,1,n);\n    std::cin&gt;&gt;q;\n    while(q--)\n    {\n        int l,r;\n        std::vector&lt;int&gt; res,id;\n        std::cin&gt;&gt;l&gt;&gt;r;\n        for(int i = 1 ; i &lt;= std::min(31,r - l + 1) ; i++)\n        {\n            std::pair&lt;int,int&gt; temp = query(1,l,r);\n            res.push_back(temp.first);\n            id.push_back(temp.second);\n            modify(1,temp.second,INF);\n        }\n        int ans = INF;\n        for(int i = 0 ; i &lt; res.size() ; i++)\n            for(int j = i + 1 ; j &lt; res.size() ; j++)ans = std::min(ans,res[i]|res[j]);\n        std::cout&lt;&lt;ans&lt;&lt;'\\n';\n        for(auto _id : id)\n        {\n            modify(1,_id,w[_id]);\n        }\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n","slug":"Codeforces-Round-781-Div-2","date":"2022-04-12T10:34:34.000Z","categories_index":"Codeforces","tags_index":"algorithm","author_index":"skynesser"},{"id":"a755efac510fc930070b9bd1314d7bb8","title":"Codeforces Round 780 (Div. 3)","content":"\nA. Vasya and Coins题意：\n\n\n\n\n\n\n\n\n\n小明有枚1元硬币和枚2元硬币，输出小明无法支付的最小金额。\n思路：\n\n\n\n\n\n\n\n\n\n\n没有1元硬币：\n\n答案为1\n\n有1元硬币：\n\n\n\n\n\n\n\n\n\n答案为 \n\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n在这里插入代码片#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 20,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    int a,b;\n    std::cin&gt;&gt;a&gt;&gt;b;\n    if(!a)\n    {\n        std::cout&lt;&lt;1&lt;&lt;'\\n';\n        return;\n    }\n    std::cout&lt;&lt;a+b*2+1&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nB. Vlad and Candies题意：\n\n\n\n\n\n\n\n\n\n有n种糖果，每个糖果有份。\n\n每次都吃掉份数最多的糖果，但是小明不希望连续两次吃一样的糖果，他是否可以按照这个要求吃掉所有糖果。\n\n思路：\n\n\n\n\n\n\n\n\n\n只需要考虑最大值和次大值即可。\n\n最大值次大值最大值次大值\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 20,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    int max1 = 0,max2 = 0;\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        if(x &gt; max1)std::swap(max1,x);\n        if(x &gt; max2)std::swap(max2,x);\n    }\n    std::cout&lt;&lt;(max1-max2 &gt; 1 ?\"NO\":\"YES\")&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nC. Get an Even String题意：\n\n\n\n\n\n\n\n\n\n给定一个字符串S，要求你删除最少的字母，让字符串S满足如下要求：\n\n\n长度为偶数\n为奇数 \n\n\n思路：\n\n\n\n\n\n\n\n\n\n很显然，我们要把相同的字母匹配起来。我们考虑如下贪心策略:\n\n形如测试案例：bmefbmuyw\n\n删除字母最少，就是保留字母最多\n我们把上述字符串中，最近的匹配字母取出，组成区间\n有\n即在这些区间中，找到尽可能多的不相交区间。\n而选择的标准就是右端点越小，那么选择一定是越好的，因为右端点越小，后面可供选择的区间一定会更多。\n\n所以实际操作过程中，每当存在一对可以匹配的字母，我们就匹配他们，并把他们中间的字母全部删除(让右端点尽可能小)。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n使用了map去存字母，所以时间复杂度增加\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 20,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    std::map&lt;char,bool&gt; mp;\n    std::string s;\n    std::cin&gt;&gt;s;\n    int res = 0;\n    for(int i = 0 ; i &lt; s.size() ; i++)\n    {\n        if(mp.count(s[i]))\n        {\n            res += 2;\n            mp.clear();\n        }\n        else mp[s[i]] = true;\n    }\n    std::cout&lt;&lt;s.size() - res &lt;&lt; '\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nD. Maximum Product Strikes Back题意：\n\n\n\n\n\n\n\n\n\n给定长度为n的数组，而且其中的每一个元素。要求从右和从左删除一定个数的元素，使得剩下元素相乘之积最大:\n\n选择和求\n\n思路：\n\n\n\n\n\n\n\n\n\n因为空数组是1，所以0是必然被删除的，所以0把整个数组划分成了若干个区间，我们对每个这样的区间求取最大值,对每个区间，我们做这样的处理：\n\n\n区间的值应该保持为正数\n我们记录区间中负数的个数和2的个数\n2的个数决定乘积大小，负数个数决定乘积是否为负。\n在乘积已经是正数的基础上，那么区间的数留下的越多肯定是越好的。\n区间内负数个数为偶数：\n\n直接把当前区间乘积最为备选答案，与此时的答案相比。\n\n区间内负数个数为奇数：\n\n\n\n\n\n\n\n\n\n分别从左和从右寻找第一个负数，取两者更优的情况。\n\n\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nvoid solve()\n{\n    int n;\n    int cnt_two = 0,cnt_negative = 0,ans = 0,last = 0;\n    std::pair&lt;int,int&gt; res;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    for(int i = 1 ; i &lt;= n + 1; i++)\n    {\n        if(a[i] == 0||i == n + 1)\n        {\n            int t = 0;\n            if(cnt_negative&amp;1)\n            {\n                for(int j = last + 1 ; j &lt; i ; j++)\n                {\n                    if(a[j] == 2||a[j] == -2)t++;\n                    if(a[j] &lt; 0)\n                    {\n                        if(cnt_two - t &gt; ans)\n                        {\n                            ans = cnt_two - t;\n                            res = {j, n + 1 - i};\n                        }\n                        break;\n                    }\n                }\n                t = 0;\n                for(int j = i - 1; j &gt; last ; j--)\n                {\n                    if(a[j] == 2||a[j] == -2)t++;\n                    if(a[j] &lt; 0)\n                    {\n                        if(cnt_two - t &gt; ans)\n                        {\n                            ans = cnt_two - t;\n                            res = {last,n + 1 - j};\n                        }\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                if(cnt_two &gt; ans)\n                {\n                    ans = cnt_two;\n                    res = {last,n + 1 - i};\n                }\n            }\n            last = i;\n            cnt_negative = cnt_two = 0;\n        }\n        else\n        {\n            if(a[i] == 2)cnt_two++;\n            else if(a[i]==-2)cnt_two++,cnt_negative++;\n            else if(a[i]==-1)cnt_negative++;\n        }\n    }\n    if(ans == 0)std::cout&lt;&lt;n&lt;&lt;\" \"&lt;&lt;0&lt;&lt;'\\n';\n    else std::cout&lt;&lt;res.first&lt;&lt;\" \"&lt;&lt;res.second&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nE. Matrix and Shifts题意：\n\n\n\n\n\n\n\n\n\n有一个的矩阵，里面的每个元素都是0和1，可以任意执行以下4种操作(无需任何代价)：\n\n\n全体上移一行(第一行到最后一行)\n全体下移一行(最后行到第一行)\n全体左移一行(最左边一行到最右边一行)\n全体右移一行(最右边一行到最左边一行)\n\n操作完后，我们可以花费一个代价，执行这样的操作：\n\n\n\n\n\n\n\n\n\n把某个元素从0变成1，或者从1变成0。\n要求变完以后，只有对角线元素是1，其余均是0。输出最小代价。\n\n思路：\n\n\n\n\n\n\n\n\n\n我们只要让尽可能多的1落在对角线上就可以了。即以如下方式遍历矩阵：\n\n\n记录下 1 最多的数量 。那么最后要修改的数量就是：\n\n在对角线上的 0 元素()\n不在对角线上的 1 元素()\n\n记录矩阵中 1 的个数为：所以最终答案为\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e3+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N][N];\n\nvoid solve()\n{\n    int n,cnt = 0,max = 0;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        std::string s;\n        std::cin&gt;&gt;s;\n        for(int j = 1 ; j &lt;= n ; j++)\n        {\n            a[i][j] = s[j-1] - '0';\n            cnt += (a[i][j] == 1);\n        }\n    }\n    for(int j = 1 ; j &lt;= n ; j++)\n    {\n        int y = j,temp = 0;\n        for(int i = 1 ; i &lt;= n ; i++)\n        {\n            if(a[i][y] == 1)temp++;\n            y++;\n            if(y==n+1)y = 1;\n        }\n        max = std::max(max,temp);\n    }\n    std::cout&lt;&lt;cnt - max + (n - max)&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nF1. Promising String (easy version)题意：\n\n\n\n\n\n\n\n\n\n给定一个由’+’和‘-’组成的字符串S，定义有希望的字符串如下：\n\n字符串可以进行如下操作：\n\n相邻的两个’-‘可以合并为’+’\n可以通过上述操作，使得字符串中’+’和‘-’的数量相同。\n\n输出字符串S中所有满足条件的子串的个数。\n\n思路：\n\n\n\n\n\n\n\n\n\n因为数据量只有3000，所以我们直接暴力枚举所有区间。检查区间合法的方法如下：\n\n\n记录下区间中‘+‘的数量cnt1，‘-‘的数量cnt0，以及可以合并的减号的最大对数cnt。\n假设合并的减号对数为:\n$cnt_{0}-2x=cnt_{1}+xcnt_{0}-cnt_{1}=3x$\n\n\n那么只需要满足为整数，而且，区间就是合法的。\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e3+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    std::string s;\n    std::cin&gt;&gt;s;\n    bool tag = false;\n    int cnt1,cnt0,cnt,res = 0;\n    for(int i = 0 ; i &lt; n ; i++)\n    {\n        cnt = 0,cnt1 = 0,cnt0 = 0;\n        for(int j = i ; j &lt; n ; j++)\n        {\n            if(s[j] == '+')cnt1++,tag = false;\n            else\n            {\n                if(tag)\n                {\n                    cnt++;\n                    cnt0++;\n                    tag = false;\n                }\n                else\n                {\n                    cnt0++;\n                    tag = true;\n                }\n            }\n            if(cnt0==cnt1)res++;\n            else\n            {\n                if(cnt0 &gt; cnt1 &amp;&amp; (cnt0 - cnt1) % 3 == 0)\n                {\n                    if(cnt &gt;= (cnt0 - cnt1)/3 )res++;\n                }\n            }\n        }\n    }\n    std::cout&lt;&lt;res&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n","slug":"Codeforces-Round-780-Div-3","date":"2022-04-12T10:34:26.000Z","categories_index":"Codeforces","tags_index":"algorithm","author_index":"skynesser"},{"id":"125917e35db77b388a3d8bf4e666f8ce","title":"Codeforces Round 779 (Div. 2)(Permutationforces)","content":"\nA. Marin and Photoshoot题意：\n\n\n\n\n\n\n\n\n\n给定一个由0和1组成的序列，现在可以往这个序列中添加1，是的这个序列满足如下要求：对于任意长度大于等于2的区间，要求这个区间中1的个数大于等于0的个数。\n思路：\n\n\n\n\n\n\n\n\n\n添加1，使得序列中不存在如下情况：00或者010即保证两个0之间的距离大于等于2。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    int n;\n    std::string s;\n    std::cin&gt;&gt;n&gt;&gt;s;\n    int res = 0,last = -1;\n    for(int i = 0 ; i &lt; n ; i++)\n    {\n        if(s[i]=='0')\n        {\n            if(last==-1)last = i;\n            else\n            {\n                if(i-last&lt;=2)res += 3 - (i - last);\n                last = i;\n            }\n        }\n    }\n    std::cout&lt;&lt;res&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nB. Marin and Anti-coprime Permutation题意：\n\n\n\n\n\n\n\n\n\n要求构造一个长度为n的全排列，满足如下要求：$gcd(1p_{1},2p_{2},\\dots n-1p_{n-1},np_{n}) &gt; 1$询问有几种方案满足上述要求。\n思路：\n\n\n\n\n\n\n\n\n\n选取任意的k，那么存在k的因子的数必然k的倍数。因此不难推知n个数里面包含k的因子的数有个，那么加上要乘的数，所以包含k的因子的个数应该是$2\\left \\lceil \\frac{n}{k} \\right \\rceil个。我们我保证2\\left \\lceil \\frac{n}{k} \\right \\rceil \\geq n，因此只能取。那么就让所有的数相乘后为偶数，即让奇数乘偶数位，偶数乘奇数位即可。若为偶数结果为(\\frac{n}{2})!*(\\frac{n}{2})!$2.若n为奇数，结果为0。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 998244353 ;\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    ll res = 1;\n    if(n&amp;1)\n    {\n        std::cout&lt;&lt;0&lt;&lt;'\\n';\n        return;\n    }\n    for(int i = 1 ; i &lt;= n/2 ; i++)\n        res = (i*res) % mod;\n    std::cout&lt;&lt;res*res%mod&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nC. Shinju and the Lost Permutation题意：\n\n\n\n\n\n\n\n\n\n给定一个全排列：再由这个全排列可以得到另一个数组a定义 c 为数组a中不同数的个数，并称 c 是数组 a 的幂。那么我们把这个数组p全体向右移动一个单位，这样又可以确定一个数组a，进而确定 c 的值。我们让表示全排列向右移动次的值。现给定数组，询问能否存在全排列，使得移动次的值等于。\n思路：\n\n\n\n\n\n\n\n\n\n产生的数组 c 要满足如下要求：1.移动过程中，我们考虑当最大数移动到第一个位置时，此时的 c 必然是 1，且只有这种情况 c 为 1。2.将1中的全排列向右移动一个单位，此时 c 必然是 2。3.那么在之后的移动过程中，c 每次最多可以增加 1(要注意，最大数以后的数必然只能为 c 提供 1 的 贡献)，或者可以减小若干。因此，我们只需要判断 c 是否满足如下情况：1.c = 1 应该有且只有一个。2.从1的位置开始判断，每次最多只会增加1，或者减小若干。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 998244353 ;\n\nint a[N];\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    int index = -1,cnt = 0;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        std::cin&gt;&gt;a[i];\n        if(a[i] == 1)index = i,cnt++;\n    }\n    if(index==-1||cnt&gt;1)\n    {\n        std::cout&lt;&lt;\"NO\\n\";\n        return;\n    }\n    for(int i = 1 ; i &lt; n ; i++)\n    {\n        int x = index + 1;\n        if(x==n+1)x = 1;\n        if(a[x] - a[index] &gt;= 2)\n        {\n            std::cout&lt;&lt;\"NO\\n\";\n            return;\n        }\n        index++;\n        if(index==n+1)index = 1;\n    }\n    std::cout&lt;&lt;\"YES\\n\";\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nD1. 388535 (Easy Version)题意：\n\n\n\n\n\n\n\n\n\n给定从L(L = 0)到R的一个全排列和一个整数 x 。现在对这个全排列的每个数都执行如下操作：给出操作完后的数组，询问是否存在 x 。\n思路：\n\n\n\n\n\n\n\n\n\n因为全排列是从0开始，我们可以发现在每一位数字上0的个数必然大于等于1的个数，因此我们我们只要保证这一条件即可构造出答案 x ：对于第  位，我们构造如下：1.若，该位取12.若，该位取0\n举例：0~700000001001000110100010101100111每一位上显然有。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 998244353 ;\n\nint a[20][2];\n\nvoid solve()\n{\n    int l,r;\n    std::cin&gt;&gt;l&gt;&gt;r;\n    memset(a,0,sizeof a);\n    for(int i = 1 ; i &lt;= r - l + 1 ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        for(int j = 0 ; j &lt;= 17 ; j++)a[j][x&gt;&gt;j&amp;1]++;\n    }\n    int res = 0;\n    for(int i = 0 ; i &lt;= 17 ; i++)\n    {\n        if(a[i][1] &gt; a[i][0])res += 1 &lt;&lt; i;\n    }\n    std::cout&lt;&lt;res&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n","slug":"Codeforces-Round-779-Div-2-Permutationforces","date":"2022-04-12T10:33:55.000Z","categories_index":"Codeforces","tags_index":"algorithm","author_index":"skynesser"},{"id":"e46a6dad08206a9d3e04ebe2b2c5fc2a","title":"CodeTON Round 1 (Div. 1 + Div. 2, Rated, Prizes)","content":"\nA. Good Pairs题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为n的序列：现在要找到一对下标满足：对所有的成立\n思路：\n\n\n\n\n\n\n\n\n\n显然只要和是最大值是最小值即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码:\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    std::cout&lt;&lt;std::max_element(a+1,a+1+n) - a&lt;&lt;\" \"&lt;&lt;std::min_element(a+1,a+1+n)-a&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nB. Subtract Operation题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为n的序列：。现在可以从中选择一个，将其删除，并让其余所有数减：。执行这样的操作若干次，直至序列中只剩下一个数。是否存在某种操作顺序，可以使最后剩下的数等于k。\n思路：\n\n\n\n\n\n\n\n\n\n假设最后留下的数是，最后一次删除的数是（原序列中的和），那么最后留下来的数为。\n证明如下：设第次删除了，得到：。设第次删除了，得到：。。\n因此，整个序列减小的数只与最后一次删除有关。最终留下的数即。那么我们只需要寻找是否存在这样的一对数，满足即可。这里在排序后二分就可以完成查找。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nvoid solve()\n{\n    int n,k;\n    std::cin&gt;&gt;n&gt;&gt;k;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    std::sort(a+1,a+1+n);\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int index = std::lower_bound(a+1,a+n+1,a[i]+k) - a;\n        if(index &lt;= n &amp;&amp; a[index] - a[i] == k)\n        {\n            std::cout &lt;&lt; \"YES\\n\";\n            return;\n        }\n    }\n    std::cout&lt;&lt;\"NO\\n\";\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nC. Make Equal With Mod题意：\n\n\n\n\n\n\n\n\n\n给定一个序列：。选择一个数，对所有数取模：。在若干次操作后是否可能使所有数相等。\n思路：\n\n\n\n\n\n\n\n\n\n第一种情况，原序列没有1：我们考虑把所有数变成0，即每次选择最大的数，令,则一次操作后只有最大的数变成0，其余数均不变。所以该情况一定有解。\n第一种情况，原序列存在1：那么我们只能考虑把所有数变成1。每次选择最大的数，令，那么取模后最大数变成1。若在此过程中序列中存在，则变成 0 ，那么不存在方案。否则存在方案。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    bool flag = false;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        flag = (a[i]==1);\n        if(flag)break;\n    }\n    if(!flag)\n    {\n        std::cout&lt;&lt;\"YES\\n\";\n    }\n    else\n    {\n        flag = false;\n        std::sort(a+1,a+1+n);\n        for(int  i = 1 ; i &lt; n ; i++)\n        {\n            flag = (a[i+1] - a[i] == 1);\n            if(flag)break;\n        }\n        if(flag)\n        {\n            std::cout&lt;&lt;\"NO\\n\";\n        }\n        else\n        {\n            std::cout&lt;&lt;\"YES\\n\";\n        }\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n \nE. Equal Tree Sums题意：\n\n\n\n\n\n\n\n\n\n给定一个无根树，每个节点有一个权值，现在我们要对节点分配一个权值，使得无论删除哪一个点，剩余的每个连通块权值之和相等。\n思路：\n\n\n\n\n\n\n\n\n\n从一个点开始遍历整棵树，起点染为白色。在遍历的时候，与白色相邻的点染为黑色，与黑色相邻的点染为白色。染色完成后，设每个点的度数为，并令：1.白色点的权值为2.黑色点的权值为赋值显然后所有整棵树的权值和为0，并且每条边对权值和的贡献为0。\n我们可以把一条边分裂成两条边，一条由黑色点指向白色点，权值为1，一条由白色点指向黑色点，权值为-1，那么一个白色点的权值就是由所有这个白色点指向黑色点的边加和而成。\n现在证明删除一个点后剩余连通块权值和相等：1.假设删除了一个黑点，权值为2.那么很显然此时有连通块3.现在我们根据上面的分边，为每个点重新赋值，那么每个连通块内部权值都为04.对于所有与黑点相连的白色点，权值相差的只是与黑点相连的这一条边的权值，其余所有点权值不变。5.所以实际上每个连通块变化的和都是一样的，为或。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(n+m)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint h[N],e[M],ne[M],idx;\nint w[N],d[N];\nbool color[N];\n\nvoid add(int a,int b)\n{\n    e[idx] = b,ne[idx] = h[a],h[a] = idx++;\n}\n\nvoid dfs(int u,int fa,bool st)\n{\n    color[u] = st;\n    for(int i = h[u] ; ~i ; i = ne[i])\n    {\n        int v = e[i];\n        d[u]++;\n        if(v==fa)continue;\n        dfs(v,u,st^1);\n    }\n}\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)h[i] = -1,d[i] = 0;\n    idx = 0;\n    for(int i = 1 ; i &lt; n ; i++)\n    {\n        int a,b;\n        std::cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    }\n    dfs(1,-1,false);\n    for(int i = 1 ; i &lt;= n ; i++)color[i] == 0 ? std::cout&lt;&lt;-d[i]&lt;&lt;\" \":std::cout&lt;&lt;d[i]&lt;&lt;\" \";\n    std::cout&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\n \n","slug":"CodeTON-Round-1-Div-1-Div-2-Rated-Prizes","date":"2022-04-12T10:33:21.000Z","categories_index":"Codeforces","tags_index":"algorithm","author_index":"skynesser"},{"id":"75e163e1709c0c17a44785b1605f0bc1","title":"AtCoder Beginner Contest 245","content":"\nA - Good morning题意：\n\n\n\n\n\n\n\n\n\n语法题：给定两个起床时间。若第一个早于等于第二个，输出，反之输出。\n思路：\n\n\n\n\n\n\n\n\n\n见代码\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e2+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int a,b,c,d;\n    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;\n    if(a*60+b&lt;=c*60+d)std::cout&lt;&lt;\"Takahashi\";\n    else std::cout&lt;&lt;\"Aoki\";\n\n    return 0;\n}\nB - Mex题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为n的序列，输出这个序列中未出现的最小自然数。\n思路：\n\n\n\n\n\n\n\n\n\n用一个数组统计数字出现次数，然后寻找这个序列中未出现的最小自然数。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e3+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint cnt[N];\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        cnt[x]++;\n    }\n    for(int i = 0 ; ; i++)\n    {\n        if(!cnt[i])\n        {\n            std::cout&lt;&lt;i;\n            return 0;\n        }\n    }\n    return 0;\n}\nC - Choose Elements题意：\n\n\n\n\n\n\n\n\n\n给定两个序列和一个整数k：要求构造出一个序列：或使得对于有:\n思路：\n\n\n\n\n\n\n\n\n\n如果对于都满足如上要求。那么显然此时是否满足要求只与有关。这种性质满足无后效性，考虑使用动态规划。我们设有：若表示第可用若表示第不可用若表示第可用若表示第不可用(这里可能用1表示可用更好，但是当时我不想初始化)即可以按如下方式转移：for(int i = 2 ; i &lt;= n ; i++)\n   {\n       if(!dp[i-1][0]&amp;&amp;abs(a[i]-a[i-1])&lt;=k||!dp[i-1][1]&amp;&amp;abs(a[i]-b[i-1])&lt;=k)dp[i][0] = 0;\n       else dp[i][0] = 1;\n       if(!dp[i-1][0]&amp;&amp;abs(b[i]-a[i-1])&lt;=k||!dp[i-1][1]&amp;&amp;abs(b[i]-b[i-1])&lt;=k)dp[i][1] = 0;\n       else dp[i][1] = 1;\n   }那么最后或存在一个可用即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(n)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N],b[N],dp[N][2];\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n,k;\n    std::cin&gt;&gt;n&gt;&gt;k;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;b[i];\n    for(int i = 2 ; i &lt;= n ; i++)\n    {\n        if(!dp[i-1][0]&amp;&amp;abs(a[i]-a[i-1])&lt;=k||!dp[i-1][1]&amp;&amp;abs(a[i]-b[i-1])&lt;=k)dp[i][0] = 0;\n        else dp[i][0] = 1;\n        if(!dp[i-1][0]&amp;&amp;abs(b[i]-a[i-1])&lt;=k||!dp[i-1][1]&amp;&amp;abs(b[i]-b[i-1])&lt;=k)dp[i][1] = 0;\n        else dp[i][1] = 1;\n    }\n    if(!dp[n][0]||!dp[n][1])std::cout&lt;&lt;\"Yes\";\n    else std::cout&lt;&lt;\"No\";\n    return 0;\n}\nD - Polynomial division题意：\n\n\n\n\n\n\n\n\n\n存在多项式：将两个多项式相乘得到：现在给出所有系数和，请输出所有的。\n思路:\n\n\n\n\n\n\n\n\n\n开始时，有，并做如下处理：$c[i]=c[i]-b[0]ai。处理完后显然有b[1]=\\frac{c[1]}{a[0]}，并重复上述处理：c[i+1]=c[i+1]-b[1]ai。因此我们可以重复上述步骤直至求出所有b_{j}(0\\leq j\\leq n)b[j]=\\frac{c[j]}{a[0]}c[i+j]=c[i+j]-b[j]*a[i]$。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N],b[N],c[N];\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int n,m;\n    std::cin&gt;&gt;n&gt;&gt;m;\n    for(int i = n ; i &gt;= 0 ; i--)std::cin&gt;&gt;a[i];\n    for(int i = m + n; i &gt;= 0 ; i--)\n    {\n        std::cin&gt;&gt;c[i];\n    }\n    for(int i = 0 ; i &lt;= m ; i++)\n    {\n        b[i] = c[i]/a[0];\n        for(int j = 1 ; j &lt;= n ; j++)\n        {\n            c[i+j] -= (b[i] * a[j]);\n        }\n    }\n    for(int i = m ; i &gt;= 0 ; i--)std::cout&lt;&lt;b[i]&lt;&lt;\" \";\n    return 0;\n}\nE - Wrapping Chocolate\n\n\n\n\n\n\n\n\n题意：有n个巧克力，宽度为，长度为。有m个盒子，宽度为，长度为。如果，那么第盒子就可以装下第个巧克力。询问是否存在一种方案，可以用盒子把所有的巧克力装下。\n思路：\n\n\n\n\n\n\n\n\n\n没看数据之前，还想着暴力跑二分图最大匹配无序查找必然超时，考虑对某个关键字排序。我们把巧克力和盒子一起按照宽度降序排序(如果宽度相同则把盒子排在前面)，遍历排序后的数组，并维护一个集合S，按照如下方式处理：1.如果当前位置为盒子：将长度加入集合。2.如果当前位置为巧克力：找到，并将删除，如果查找失败，则不存在方案。易证明上述操作可以完成题目要求，上述操作可以用multiset完成。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(nlogn)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 4e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y;\n    bool box;\n    bool operator&lt;(const Node &amp;a)const\n    {\n        if(a.x == x)return a.box &lt; box;\n        return a.x &lt; x;\n    }\n}a[N];\nstd::multiset&lt;int&gt; st;\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n,m;\n    std::cin&gt;&gt;n&gt;&gt;m;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        a[i].x = x;\n    }\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        a[i].y = x;\n        a[i].box = false;\n    }\n    for(int i = n + 1 ; i &lt;= m + n; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        a[i].x = x;\n    }\n    for(int i = n + 1 ; i &lt;= m + n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        a[i].y = x;\n        a[i].box = true;\n    }\n    std::sort(a+1,a+1+n+m);\n    for(int i = 1 ; i &lt;= n + m; i++)\n    {\n        if(a[i].box)\n        {\n            st.insert(a[i].y);\n        }\n        else\n        {\n            auto it = st.lower_bound(a[i].y);\n            if(it!=st.end())st.erase(it);\n            else\n            {\n                std::cout&lt;&lt;\"No\";\n                return 0;\n            }\n        }\n    }\n    std::cout&lt;&lt;\"Yes\";\n    return 0;\n}\nF - Endless Walk题意：\n\n\n\n\n\n\n\n\n\n给定一张有向图，寻找这样的点，满足如下要求：从这个点出发，存在一条无限长的路径。输出有几个点满足上述要求。\n思路：\n\n\n\n\n\n\n\n\n\n满足上述的点存在两种情况：1.该点在环内2.从这个点出发可以走到环我的处理可能复杂些，按照如下步骤：1.强连通分量跑tarjan缩点，对于任意的强连通分量，若内部点数，则这些点都在环内。2.若选择这样的做法，细节较多：从其他点开始搜索，尝试是否能走到环。尝试采用另一种方法：建立反向图，从环开始搜索，对于所有搜索到的点，都满足要求。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(n+m)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint h[N],hs[N],e[M],ne[M],idx;\nint id[N],dfn[N],low[N],stk[N],size[N],scc,top,ts;\nbool book[N],vis[N],OK[N];\nint res;\n\nvoid add(int h[],int a,int b)\n{\n    e[idx] = b,ne[idx] = h[a],h[a] = idx++;\n}\n\nvoid tarjan(int u)\n{\n    dfn[u] = low[u] = ++ts;\n    book[u] = true,stk[++top] = u;\n    for(int i = h[u] ; ~i ; i = ne[i])\n    {\n        int v = e[i];\n        if(!dfn[v])\n        {\n            tarjan(v);\n            low[u] = std::min(low[u],low[v]);\n        }\n        else if(book[v])low[u] = std::min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        int temp;\n        scc++;\n        do{\n            temp = stk[top--];\n            book[temp] = false;\n            id[temp] = scc;\n            size[scc]++;\n        }while(temp!=u);\n    }\n}\n\nvoid dfs(int u)\n{\n    res++,vis[u] = OK[u] = true;\n    for(int i = hs[u] ; ~i ; i = ne[i])\n    {\n        int v = e[i];\n        if(vis[v])continue;\n        dfs(v);\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    memset(h,-1,sizeof h);\n    memset(hs,-1,sizeof hs);\n    int n,m;\n    std::cin&gt;&gt;n&gt;&gt;m;\n    while(m--)\n    {\n        int a,b;\n        std::cin&gt;&gt;a&gt;&gt;b;\n        add(h,a,b),add(hs,b,a);\n    }\n    for(int i = 1 ; i &lt;= n ; i++)if(!dfn[i])tarjan(i);\n    for(int i = 1 ; i &lt;= n ; i++)\n        if(size[id[i]] &gt; 1)OK[i] = true;\n    for(int i = 1 ; i &lt;= n ; i++)if(OK[i]&amp;&amp;!vis[i])dfs(i);\n    std::cout&lt;&lt;res;\n    return 0;\n}\nG - Foreign Friends题意：\n\n\n\n\n\n\n\n\n\n现有N个人，这些人属于K个国家，这N个人中有L个人是受欢迎的人，这L个人分别属于不同的国家。小明是个中间人，存在M对关系：小明可以让某一对中的两个人相互认识，但是要花费一定的金额。对于这N个人中的每一个人，他们都想要认识一个不在自己国家的受欢迎的人,分别输出这N个人所需的最小花费。(若a认识b，b认识c，那么有a认识c)\n思路：\n\n\n\n\n\n\n\n\n\n比较显然的，这是一个最短路问题,可以使用Dijkstra(使用优先队列)。正向考虑跑最短路显然不行，我们反向考虑让每个受欢迎的人去认识每一个人，但是我们如果让每个受欢迎的人去跑最短路，时间复杂度也会达到，但是这题比较特殊，我们可以进行如下考虑：1.我们把所有受欢迎的人放在优先队列里同时跑最短路，并记录他们所属的国家,在这个过程中我们通过记录，保证每个国家只会更新一次。2.那么当人被第一次和第二次取出的时候，所需的花费分别是最小，次小的，并且更新这两次的国家不同。因为只会属于一个国家，所以这两个最小数中一定有一个和自己的国家不同。3.如果与更新最小值的国家不同，输出最小值即可，反之输出次小值。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(nlogn)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    ll dist;\n    int u,city;\n    bool operator &lt;(const Node &amp;a)const\n    {\n        return a.dist &lt; dist;\n    }\n};\nint h[N],e[N],ne[N],w[N],idx;\nint vis[N],city[N],type[N];\nll dist1[N],dist2[N];\nint n,m,k,l;\nstd::priority_queue&lt;struct Node&gt; que;\n\nvoid add(int a,int b,int c)\n{\n    e[idx] = b,ne[idx] = h[a],w[idx] = c,h[a] = idx++;\n}\n\nvoid Dijkstra()\n{\n    while(!que.empty())\n    {\n        auto temp = que.top();\n        que.pop();\n        if(vis[temp.u] &lt; 2 &amp;&amp; type[temp.u] != temp.city)\n        {\n            if(vis[temp.u] == 0) type[temp.u] = temp.city,dist1[temp.u] = temp.dist;\n            else dist2[temp.u] = temp.dist;\n            vis[temp.u]++;\n            for(int i = h[temp.u] ; ~i ; i = ne[i])\n            {\n                int v = e[i];\n                que.push({temp.dist+w[i],v,temp.city});\n            }\n        }\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    memset(h,-1,sizeof h);\n    std::cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;l;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;city[i];\n    for(int i = 1 ; i &lt;= l ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        que.push({0ll,x,city[x]});\n    }\n    while(m--)\n    {\n        int a,b,c;\n        std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        add(a,b,c),add(b,a,c);\n    }\n    Dijkstra();\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        if(type[i] != city[i]&amp;&amp;dist1[i])std::cout&lt;&lt;dist1[i]&lt;&lt;\" \";\n        else if(dist2[i])std::cout&lt;&lt;dist2[i]&lt;&lt;\" \";\n        else std::cout&lt;&lt;-1&lt;&lt;\" \";\n    }\n    return 0;\n}\n","slug":"AtCoder-Beginner-Contest-245","date":"2022-04-12T10:32:05.000Z","categories_index":"Atcoder","tags_index":"algorithm","author_index":"skynesser"},{"id":"3e603a5ebaa3bb11ce97c7711a41ebdb","title":"AtCoder Beginner Contest 246","content":"\n\nA - Four Points题意：\n\n\n\n\n\n\n\n\n\n给出三个点，找到一个点，让这4个点组成一个矩形\n思路：\n\n\n\n\n\n\n\n\n\n分别找到横纵坐标中只有一个的值。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e2+5,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int x,y,ans_x = 0,ans_y = 0;\n    for(int i = 1 ; i &lt;= 3 ; i++)\n    {\n        std::cin&gt;&gt;x&gt;&gt;y;\n        ans_x ^= x,ans_y ^= y;\n    }\n    std::cout&lt;&lt;ans_x&lt;&lt;' '&lt;&lt;ans_y;\n    return 0;\n}\n\n\nB - Get Closer题意：\n\n\n\n\n\n\n\n\n\n给出一个向量，将其变成单位向量。\n思路：\n\n\n\n\n\n\n\n\n\n将向量除以他的模即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e2+5,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    double x,y;\n    scanf(\"%lf%lf\",&amp;x,&amp;y);\n    printf(\"%.10f %.10f\",x / sqrt(x*x+y*y),y / sqrt(x*x+y*y));\n    return 0;\n}\n\n\nC - Coupon题意：\n\n\n\n\n\n\n\n\n\n给定n个商品，每个商品的价格是，现在有k张优惠券，每张优惠券可以减少某个商品x元(不得低于0)，询问购买全部商品的最小花费。\n思路：\n\n\n\n\n\n\n\n\n\n先保证不浪费优惠券的情况下，把尽可能多的商品价格减免到x元以下，然后如果还有优惠券剩余，我们对剩下的商品价格从高到低使用优惠券。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int n,k,x;\n    std::cin&gt;&gt;n&gt;&gt;k&gt;&gt;x;\n    for(int i = 1; i &lt;= n ; i++)\n    {\n        std::cin&gt;&gt;a[i];\n        if(k == 0)continue;\n        if(k &gt;= a[i]/x)\n        {\n            k -= a[i]/x;\n            a[i] %= x;\n        }\n        else\n        {\n            a[i] -= k * x;\n            k = 0;\n        }\n    }\n    ll sum = 0;\n    std::sort(a+1,a+1+n,std::greater&lt;int&gt;());\n    for(int i = 1 + k ; i &lt;= n ; i++)sum += a[i];\n    std::cout&lt;&lt;sum;\n    return 0;\n}\n\n\nD - 2-variable Function题意：\n\n\n\n\n\n\n\n\n\n给定一个数n，找到一个数x，满足下列两个条件：\n\n\n\n使得\n\n\n思路：\n\n\n\n\n\n\n\n\n\n我们可以使用双指针，从小到大枚举，从大到小，从而枚举出所有的，并从中找到最小值。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1500+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\n\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    ll n;\n    std::cin&gt;&gt;n;\n    ll res = 1e18;\n    ll j = 1e6;\n    for(ll i = 0 ; i &lt;= 1e6 ; i++)\n    {\n        ll temp = i*i*i+i*i*j+i*j*j+j*j*j;\n        while(temp &gt;= n &amp;&amp; j &gt;= 0)\n        {\n            res = std::min(res,temp);\n            j--;\n            temp = i*i*i+i*i*j+i*j*j+j*j*j;\n        }\n    }\n    std::cout&lt;&lt;res;\n    return 0;\n}\n\n\nE - Bishop 2题意：\n\n\n\n\n\n\n\n\n\n给出一个的地图，其中是平地，其中#是障碍，并给出一个起点和终点，在不跨越障碍的情况下，可以往左上，右上，右下，左下四个斜角方向一次移动任意个单位，询问从起点移动到终点的最小步数，若不存在路径，则输出-1。\n思路：\n\n\n\n\n\n\n\n\n\n修改正常BFS的拓展方式即可，每次拓展的时候把四个斜角方向可以拓展的点全部拓展。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1500+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y,step;\n}que[N*N];\nchar a[N][N];\nbool book[N][N];\nint ne[4][2] = {1,1,1,-1,-1,1,-1,-1};\nint n,start_x,start_y,end_x,end_y;\n\nbool OK(int x,int y)\n{\n    if(x&lt;1||y&lt;1||x&gt;n||y&gt;n||a[x][y]=='#')return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int head = 0,tail = -1;\n    que[++tail] = {start_x,start_y,0};\n    book[start_x][start_y] = true;\n    while(tail&gt;=head)\n    {\n        auto temp = que[head++];\n        if(temp.x == end_x &amp;&amp; temp.y == end_y)\n        {\n            std::cout&lt;&lt;temp.step;\n            return;\n        }\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.x + ne[i][0];\n            int ty = temp.y + ne[i][1];\n            while(OK(tx,ty))\n            {\n                if(!book[tx][ty])que[++tail] = {tx,ty,temp.step+1};\n                book[tx][ty] = true;\n                tx += ne[i][0];\n                ty += ne[i][1];\n            }\n        }\n    }\n    std::cout&lt;&lt;-1;\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    std::cin&gt;&gt;n&gt;&gt;start_x&gt;&gt;start_y&gt;&gt;end_x&gt;&gt;end_y;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;(a[i]+1);\n    bfs();\n    return 0;\n}\n\n\nF - typewriter题意：\n\n\n\n\n\n\n\n\n\n给出n个键盘，每个键盘可以打印字母由一个字符串表示，现在要打印一个长度为L的字符串，每次选择一个键盘打印字符串，可以打印出多少不同的字符串。\n思路：\n\n\n\n\n\n\n\n\n\n应用容斥原理，以n=3为例：\n\nans =+（只使用第一个键盘）+（只使用第二个键盘）+（只使用第三个键盘）-（只使用第一个键盘和第二个键盘共有的字母打印）-（只使用第一个键盘和第三个键盘共有的字母打印）-（只使用第二个键盘和第三个键盘共有的字母打印）+（使用所用键盘共有的字母打印）。\n因此我们只需要枚举上述所有情况，求出答案即可。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\nN个字母所能打印的长度为L的字符串的个数为。使用快速幂会花费的时间。此外，枚举所有的情况是所以总时间复杂度为\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 30,M = 2e4+10,INF = 0x3f3f3f3f,mod = 998244353;\n\nbool temp[N],a[N][N];\nll ans,n,len;\n\nll quickPow(ll x,ll k)\n{\n    ll res = 1;\n    while(k)\n    {\n        if(k&amp;1)res = (x * res) % mod;\n        x = x * x % mod;\n        k &gt;&gt;= 1;\n    }\n    return res;\n}\n\nvoid dfs(int u,int cnt)\n{\n    if(u==n)\n    {\n        if(cnt==0)return;\n        int count = 0;\n        for(int i = 0 ; i &lt; 26 ; i++)if(temp[i])count++;\n        if(cnt&amp;1)ans = (ans + quickPow(count,len)) % mod;\n        else ans = (ans - quickPow(count,len) + mod) % mod;\n        return;\n    }\n    dfs(u+1,cnt);\n    bool last[N];\n    memcpy(last,temp,sizeof temp);\n    for(int i = 0 ; i &lt; 26 ; i++)temp[i] &amp;= a[u][i];\n    dfs(u+1,cnt+1);\n    memcpy(temp,last,sizeof temp);\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::cin&gt;&gt;n&gt;&gt;len;\n    for(int i = 0 ; i &lt; n ; i++)\n    {\n        std::string s;\n        std::cin&gt;&gt;s;\n        for(int j = 0 ; j &lt; s.size() ; j++) a[i][s[j]-'a'] = true;\n    }\n    for(int i = 0 ; i &lt; 26 ; i++)temp[i] = true;\n    dfs(0,0);\n    std::cout&lt;&lt;ans;\n    return 0;\n}\n\nG - Game on Tree 3题意：\n\n\n\n\n\n\n\n\n\n给定一棵根为1的树，除了根，每个点都有一个权值，现在小明和小红从根节点开始按照如下规则玩一个游戏：\n\n\n小红任意选择一个点，把这个点的权值变为0\n小明从当前点出发，可以走到任意一个儿子节点\n然后小明可以决定是否结束游戏(如果小明在叶子节点则必须结束游戏)\n\n最后小明获得的分数就是小明所在点的权值，小明希望获得的分数尽可能得高，小红希望小明获得的分数尽可能的低,假设两人都足够聪明的情况下(即总是做出对当前最有利的操作)，小明可以获得的最大分数是多少。\n\n思路：\n\n\n\n\n\n\n\n\n\n使用动态规划(树形dp)和二分答案。考虑对于某一个分数，小明是否存在方案可以获得比大的分数：\n\n我们令的点为1，的点为0，。如果要使小明无法获得分数，那么必须要使这些为1的点变成0，我们假设为小明在点开始游戏小红所需要的消除次数。那么对于某个点的，我们可以用如下式子求出：\n\n\n如果当前点,那么肯定是要消除的，在小明走到儿子节点之前，我们还有一次消除机会(开始游戏时小红是先手)，所以还要加上。\n最后可以求得，如果，那么小明是可以获得一个比大的分数的。\n\n最后用二分找到最大值即可。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 998244353;\n\nint h[N],e[M],ne[M],idx;\nint w[N],dp[N];\n\nvoid add(int a,int b)\n{\n    e[idx] = b,ne[idx] = h[a],h[a] = idx++;\n}\n\nvoid dfs(int u,int fa,int val)\n{\n    dp[u] = (w[u] &gt;= val);\n    int sum = 0;\n    for(int i = h[u] ; ~i ; i = ne[i])\n    {\n        int v = e[i];\n        if(v==fa)continue;\n        dfs(v,u,val);\n        sum += dp[v];\n    }\n    dp[u] += std::max(0,sum-1);\n}\n\nbool check(int val)\n{\n    dfs(1,-1,val);\n    return dp[1] != 0;\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n;\n    std::cin&gt;&gt;n;\n    memset(h,-1,sizeof h);\n    int max = -1;\n    for(int i = 2 ; i &lt;= n ; i++)std::cin&gt;&gt;w[i],max = std::max(max,w[i]);\n    for(int i = 1 ; i &lt; n ; i++)\n    {\n        int a,b;\n        std::cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    }\n    w[0] = -1;\n    int L = 0,R = max;\n    while(R&gt;L)\n    {\n        int mid = L + R + 1 &gt;&gt; 1;\n        if(check(mid))L = mid;\n        else R = mid - 1;\n    }\n    std::cout&lt;&lt;L;\n    return 0;\n}\n\nEx - 01? Queries题意：\n\n\n\n\n\n\n\n\n\n给定一个由和组成的字符串,我们可以任意得将替换成或,求字符串的所有子串可以形成的不同的01串有多少种。现在存在q个操作,每次操作将第x个字符变成或,询问每次操作后的答案。\n思路：\n\n\n\n\n\n\n\n\n\n我们先考虑在某种情况下的01串种数。考虑动态规划,定义和分别表示前个字母所能组成的以0结尾的和以1结尾的种数。那么应该有如下状态转移方程:\n\n\n\n\n\n\n我们将上述状态转移方程用矩阵表示:\n\n\n\n\n\n\n\n\n\n分别的,对于不同的,有:\n\n\n此外有\n我们可以用线段树维护每一个矩阵,这样修改操作可以在时间内完成。\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 998244353;\nstruct Node{\n    int l,r;\n    ll a[3][3];\n}tr[N*4];\n\nchar s[N];\nint n,q;\n\nvoid pushup(int u)\n{\n    memset(tr[u].a,0,sizeof tr[u].a);\n    for(int i = 0 ; i &lt; 3 ; i++)\n        for(int j = 0 ; j &lt; 3 ; j++)\n        {\n            for(int k = 0 ; k &lt; 3 ; k++)\n                tr[u].a[i][j] = (tr[u].a[i][j] + tr[u&lt;&lt;1].a[i][k]*tr[u&lt;&lt;1|1].a[k][j])%mod;\n        }\n}\n\nvoid assign(Node &amp;root,char ch)\n{\n    if(ch=='0')\n    {\n        root.a[0][0] = 1;\n        root.a[0][1] = 1;\n        root.a[0][2] = 1;\n        root.a[1][0] = 0;\n        root.a[1][1] = 1;\n        root.a[1][2] = 0;\n        root.a[2][0] = 0;\n        root.a[2][1] = 0;\n        root.a[2][2] = 1;\n    }\n    else if(ch=='1')\n    {\n        root.a[0][0] = 1;\n        root.a[0][1] = 0;\n        root.a[0][2] = 0;\n        root.a[1][0] = 1;\n        root.a[1][1] = 1;\n        root.a[1][2] = 1;\n        root.a[2][0] = 0;\n        root.a[2][1] = 0;\n        root.a[2][2] = 1;\n    }\n    else\n    {\n        root.a[0][0] = 1;\n        root.a[0][1] = 1;\n        root.a[0][2] = 1;\n        root.a[1][0] = 1;\n        root.a[1][1] = 1;\n        root.a[1][2] = 1;\n        root.a[2][0] = 0;\n        root.a[2][1] = 0;\n        root.a[2][2] = 1;\n    }\n}\n\nvoid build(int u,int l,int r)\n{\n    if(l==r)\n    {\n        tr[u] = {l,r};\n        assign(tr[u],s[r]);\n    }\n    else\n    {\n        int mid = l + r &gt;&gt; 1;\n        tr[u] = {l,r};\n        build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r);\n        pushup(u);\n    }\n}\n\nvoid modify(int u,int x,char ch)\n{\n    if(tr[u].l==x&amp;&amp;tr[u].r==x)\n    {\n        assign(tr[u],ch);\n    }\n    else\n    {\n        int mid = tr[u].l + tr[u].r &gt;&gt; 1;\n        if(x &lt;= mid)modify(u&lt;&lt;1,x,ch);\n        else modify(u&lt;&lt;1|1,x,ch);\n        pushup(u);\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::cin&gt;&gt;n&gt;&gt;q;\n    std::cin&gt;&gt;(s+1);\n    build(1,1,n);\n    while(q--)\n    {\n        int x;\n        char ch;\n        std::cin&gt;&gt;x&gt;&gt;ch;\n        modify(1,x,ch);\n        std::cout&lt;&lt;(tr[1].a[0][2]+tr[1].a[1][2])%mod&lt;&lt;'\\n';\n    }\n    return 0;\n}\n\n","slug":"AtCoder-Beginner-Contest-246","date":"2022-04-12T09:34:16.000Z","categories_index":"Atcoder","tags_index":"algorithm","author_index":"skynesser"}]