[{"id":"0e8f626ea0dbc25b970b50c6d6ca6667","title":"Codeforces Round 781 (Div. 2)","content":"\n@[toc]\n\nA. GCD vs LCM题意：\n\n\n\n\n\n\n\n\n\n给定数n，找到a,b,c,d四个数满足下列条件：\n\n1.2.\n\n思路：\n\n\n\n\n\n\n\n\n\n取特殊情况，令即可。即构造\n时间复杂度：\n\n\n\n\n\n\n\n\n\n所需时间与输入规模无关:\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\nconst int N = 2e2+10,M = 2e5+10,INF = 0x3f3f3f3f;\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    std::cout&lt;&lt;1&lt;&lt;' '&lt;&lt;n-3&lt;&lt;1&lt;&lt;' '&lt;&lt;1&lt;&lt;'\\n';\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\nB. Array Cloning Technique题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为n的初始数组副本，你可以进行以下两种操作：\n\n\n选择任意一个数组副本，将其复制出一个新的数组副本。\n选择两个数组副本，交换它们的两个元素。\n\n询问将其中任意一个数组副本的全部元素变相同的最少操作次数。\n\n思路：\n\n\n\n\n\n\n\n\n\n\n首先，我们贪心的选择第一个数组副本作为目标，将这个数组的全部元素变成相同。\n然后，我们记录下初始数组副本中的最大相同数字出现次数,那么将其他所有元素变成相同的交换(操作1)次数显然是。\n接着我们计算复制数组副本的次数(操作2)，我们不难发现每次复制并交换结束后，相同数的个数都会翻倍，所以我们通过这种方式找到最小复制次数即可。\n\n最后，将操作1和操作2的次数相加即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n统计相同数字的最大出现次数中使用了map来完成，所以时间复杂度为：\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\nconst int N = 2e2+10,M = 2e5+10,INF = 0x3f3f3f3f;\n\nvoid solve()\n{\n    int n;\n    int max = 0;\n    std::cin&gt;&gt;n;\n    std::map&lt;int,int&gt; mp;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        mp[x]++;\n        if(mp[x] &gt; max)max = mp[x];\n    }\n    int res = 0,cnt = n - max;\n    if(cnt==0)std::cout&lt;&lt;0&lt;&lt;'\\n';\n    else\n    {\n        for(;max &lt; n;max &lt;&lt;= 1)res++;\n        res += cnt;\n        std::cout&lt;&lt;res&lt;&lt;'\\n';\n    }\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\nC. Tree Infection题意：\n\n\n\n\n\n\n\n\n\n给定一棵树，现在要去感染这棵树的全部节点，我们可以在每个单位时间内执行以下两种操作(同时进行)：\n\n\n对于所有的节点，如果他的某个孩子节点被感染，那么可以感染一个其它健康的孩子节点。2.任意选择一个健康的节点，并感染它。\n\n询问将整棵树感染的最少时间。 \n\n思路：\n\n\n\n\n\n\n\n\n\n首先，我们可以发现，感染传播(操作1)只会在一个个”孩子群体”中进行，实际上感染与树并没有太大的关系，我们完全可以把这一个个”孩子群体”取出来。还是举个例子(第一个案例)：\n\n71 1 1 2 2 4很显然，这里的”群体”有这些：{1},{2,3,4},{5,6},{7}\n我们可以先把所有的群体找出来，然后采用贪心策略，从数量大的群体开始感染，采用如下判断方法：\n\n\n\n\n\n\n\n\n\n\n我们从大到小感染所有”群体”(依次对所有”群体”使用操作1一次，然后让它们内部传播)，我们记录下完成上述操作后所有群体还剩下的未感染个数(如果已经全部感染则不用管)。\n如果此时还有剩余节点未被感染，我们让它们内部传播，并手动感染剩余节点最多的”群体”。\n\n即在贪心后模拟感染的过程(实现上可能还是有点复杂了)。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n使用了map和优先队列，总时间复杂度：\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\nconst int N = 2e2+10,M = 2e5+10,INF = 0x3f3f3f3f;\n\nvoid solve()\n{\n    int n,t = 0;\n    std::cin&gt;&gt;n;\n    std::priority_queue&lt;int&gt; que;\n    std::map&lt;int,int&gt; mp;\n    mp[0] = 1;\n    for(int i = 1 ; i &lt; n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        mp[x]++;\n    }\n    std::vector&lt;int&gt; num;\n    for(auto map : mp)num.push_back(map.second);//从大到小排序\"群体\"\n    std::sort(num.begin(),num.end());\n    for(auto val : num)//第一步\n    {\n        if(val - 1 - t &gt; 0)que.push(val - 1 - t);\n        t++;\n    }\n    int res = 0;\n    while(true)\n    {\n        if(que.empty()||que.top() - res &lt;= 0)break;//第二步\n        que.push(que.top()-1);\n        que.pop();\n        res++;\n    }\n    std::cout&lt;&lt;res+t&lt;&lt;'\\n';\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\nD. GCD Guess题意：\n\n\n\n\n\n\n\n\n\n交互题：先要猜测一个整数x的大小，你可以按照以下规则询问最多30次：\n\n给出数字和，返回\n\n思路：\n\n\n\n\n\n\n\n\n\n30次的询问次数，我们应该尝试从位的角度取解决。那么我们怎么知道每一位取0还是1呢，按照如下方法：\n\n\n假设我们已知\n那么的~位应该全是0\n我们可以用是否等于来判断位取0还是1。\n若等于，则取1，若不等，则取0。\n此时询问的，而询问数应该大于0，所以我们询问。\n若等于，则取0，若不等，则取1。\n（这个转换是为了凑出a和b）,所以询问为。\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n我们每次询问可以确定数的某一位：\nAC代码：\n#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 2e2+10,M = 2e5+10,INF = 0x3f3f3f3f;\n\nint query(int x,int y)\n{\n    std::cout&lt;&lt;\"? \"&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;std::endl;\n    int res;\n    std::cin&gt;&gt;res;\n    return res;\n}\n\nvoid solve()\n{\n    int ans = 0;\n    for(int i = 1 ; i &lt;= 30 ; i++)\n    {\n        int res = query((1&lt;&lt;i-1)-ans,(1&lt;&lt;i)+(1&lt;&lt;i-1)-ans);\n        if(res != (1&lt;&lt;i-1))ans += (1&lt;&lt;i-1);\n    }\n    std::cout&lt;&lt;\"! \"&lt;&lt;ans&lt;&lt;std::endl;\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\nE. MinimizOR题意：\n\n\n\n\n\n\n\n\n\n给定长度为n的数组，定义花费为，现在给出q个询问：\n\n给出整数和，找出区间内的最小花费。\n\n思路：\n\n\n\n\n\n\n\n\n\n本题最重要的是证明一个性质：\n\n如果区间内的最大数(即最大数不超过k位),那么答案一定在个区间最小数内按位或产生。证明如下：\n\n对,只有0和1两个数，显然成立。现在我们将设结论对成立，我们尝试证明对也成立。分类讨论：\n\n若位全是1，那么答案必然出现在之前已经选择的个数中，而且此时选择的个最小数与之前应该是一致的。\n若位0的个数大于等于2，那么答案必然出现在之前已经选择的k+1个数中，而且此时选择的个最小数与之前应该是一致的。\n若位0的个数恰好等于1，应该取1，所以答案还是出现在之前选择的个数中，但是此时选择的个最小数与之前不一定一致，因为最坏情况就是之前个数位全是1，而此时位是0的一个数会取代其中的一个数，所以我们这个时候要多取一个数，取个最小数即可。\n\n通过以上说明，我们证明结论：\n\n\n\n\n\n\n\n\n\n如果区间内的最大数(即最大数不超过k位),那么答案一定在个区间最小数内按位或产生\n\n现在的任务就是找到区间最小数，这个可以用线段树完成。此外，因为的范围并不会很大，所以我们每次并不会真的求出它，我们每次都假定它在边界最大值，所以每次最多找到31个最小数。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n这题的常数会特别大，因为每次询问都需要查找最多31次。\nAC代码：\n#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nconst int N = 1e5+10,M = 2e5+10,INF = (1ll&lt;&lt;31)-1;\nstruct Node{\n    int l,r,v,id;\n}tr[N*4];\nint w[N];\n\nvoid pushup(int u)\n{\n    tr[u].v = std::min(tr[u&lt;&lt;1].v,tr[u&lt;&lt;1|1].v);\n    if(tr[u&lt;&lt;1].v &lt; tr[u&lt;&lt;1|1].v)tr[u].id = tr[u&lt;&lt;1].id;\n    else tr[u].id = tr[u&lt;&lt;1|1].id;\n}\n\nvoid build(int u,int l,int r)\n{\n    if(l==r)\n    {\n        tr[u] = {l,r,w[r],r};\n    }\n    else\n    {\n        tr[u] = {l,r};\n        int mid = l + r &gt;&gt; 1;\n        build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r);\n        pushup(u);\n    }\n}\n\nstd::pair&lt;int,int&gt; query(int u,int l,int r)\n{\n    if(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)\n    {\n        return std::make_pair(tr[u].v,tr[u].id);\n    }\n    else\n    {\n        int mid = tr[u].l + tr[u].r &gt;&gt; 1;\n        std::pair&lt;int,int&gt; ans = {INF,INF};\n        if(l &lt;= mid)ans = std::min(ans,query(u&lt;&lt;1,l,r));\n        if(r &gt; mid)ans = std::min(ans,query(u&lt;&lt;1|1,l,r));\n        return ans;\n    }\n}\n\nvoid modify(int u,int x,int v)\n{\n    if(tr[u].l==x&amp;&amp;tr[u].r==x)\n    {\n        tr[u].v = v;\n    }\n    else\n    {\n        int mid = tr[u].l + tr[u].r &gt;&gt; 1;\n        if(x &lt;= mid)modify(u&lt;&lt;1,x,v);\n        else modify(u&lt;&lt;1|1,x,v);\n        pushup(u);\n    }\n}\n\nvoid solve()\n{\n    int n,q;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;w[i];\n    build(1,1,n);\n    std::cin&gt;&gt;q;\n    while(q--)\n    {\n        int l,r;\n        std::vector&lt;int&gt; res,id;\n        std::cin&gt;&gt;l&gt;&gt;r;\n        for(int i = 1 ; i &lt;= std::min(31,r - l + 1) ; i++)\n        {\n            std::pair&lt;int,int&gt; temp = query(1,l,r);\n            res.push_back(temp.first);\n            id.push_back(temp.second);\n            modify(1,temp.second,INF);\n        }\n        int ans = INF;\n        for(int i = 0 ; i &lt; res.size() ; i++)\n            for(int j = i + 1 ; j &lt; res.size() ; j++)ans = std::min(ans,res[i]|res[j]);\n        std::cout&lt;&lt;ans&lt;&lt;'\\n';\n        for(auto _id : id)\n        {\n            modify(1,_id,w[_id]);\n        }\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n","slug":"Codeforces-Round-781-Div-2","date":"2022-04-12T10:34:34.000Z","categories_index":"Codeforces","tags_index":"algorithm","author_index":"Aurora"},{"id":"a755efac510fc930070b9bd1314d7bb8","title":"Codeforces Round 780 (Div. 3)","content":"\n@[toc]\nA. Vasya and Coins题意：\n\n\n\n\n\n\n\n\n\n小明有枚1元硬币和枚2元硬币，输出小明无法支付的最小金额。\n思路：\n\n\n\n\n\n\n\n\n\n\n没有1元硬币：\n\n答案为1\n\n有1元硬币：\n\n\n\n\n\n\n\n\n\n答案为 \n\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n在这里插入代码片#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 20,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    int a,b;\n    std::cin&gt;&gt;a&gt;&gt;b;\n    if(!a)\n    {\n        std::cout&lt;&lt;1&lt;&lt;'\\n';\n        return;\n    }\n    std::cout&lt;&lt;a+b*2+1&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nB. Vlad and Candies题意：\n\n\n\n\n\n\n\n\n\n有n种糖果，每个糖果有份。\n\n每次都吃掉份数最多的糖果，但是小明不希望连续两次吃一样的糖果，他是否可以按照这个要求吃掉所有糖果。\n\n思路：\n\n\n\n\n\n\n\n\n\n只需要考虑最大值和次大值即可。\n\n最大值次大值最大值次大值\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 20,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    int max1 = 0,max2 = 0;\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        if(x &gt; max1)std::swap(max1,x);\n        if(x &gt; max2)std::swap(max2,x);\n    }\n    std::cout&lt;&lt;(max1-max2 &gt; 1 ?\"NO\":\"YES\")&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nC. Get an Even String题意：\n\n\n\n\n\n\n\n\n\n给定一个字符串S，要求你删除最少的字母，让字符串S满足如下要求：\n\n\n长度为偶数\n为奇数 \n\n\n思路：\n\n\n\n\n\n\n\n\n\n很显然，我们要把相同的字母匹配起来。我们考虑如下贪心策略:\n\n形如测试案例：bmefbmuyw\n\n删除字母最少，就是保留字母最多\n我们把上述字符串中，最近的匹配字母取出，组成区间\n有\n即在这些区间中，找到尽可能多的不相交区间。\n而选择的标准就是右端点越小，那么选择一定是越好的，因为右端点越小，后面可供选择的区间一定会更多。\n\n所以实际操作过程中，每当存在一对可以匹配的字母，我们就匹配他们，并把他们中间的字母全部删除(让右端点尽可能小)。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n使用了map去存字母，所以时间复杂度增加\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 20,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    std::map&lt;char,bool&gt; mp;\n    std::string s;\n    std::cin&gt;&gt;s;\n    int res = 0;\n    for(int i = 0 ; i &lt; s.size() ; i++)\n    {\n        if(mp.count(s[i]))\n        {\n            res += 2;\n            mp.clear();\n        }\n        else mp[s[i]] = true;\n    }\n    std::cout&lt;&lt;s.size() - res &lt;&lt; '\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nD. Maximum Product Strikes Back题意：\n\n\n\n\n\n\n\n\n\n给定长度为n的数组，而且其中的每一个元素。要求从右和从左删除一定个数的元素，使得剩下元素相乘之积最大:\n\n选择和求\n\n思路：\n\n\n\n\n\n\n\n\n\n因为空数组是1，所以0是必然被删除的，所以0把整个数组划分成了若干个区间，我们对每个这样的区间求取最大值,对每个区间，我们做这样的处理：\n\n\n区间的值应该保持为正数\n我们记录区间中负数的个数和2的个数\n2的个数决定乘积大小，负数个数决定乘积是否为负。\n在乘积已经是正数的基础上，那么区间的数留下的越多肯定是越好的。\n区间内负数个数为偶数：\n\n直接把当前区间乘积最为备选答案，与此时的答案相比。\n\n区间内负数个数为奇数：\n\n\n\n\n\n\n\n\n\n分别从左和从右寻找第一个负数，取两者更优的情况。\n\n\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nvoid solve()\n{\n    int n;\n    int cnt_two = 0,cnt_negative = 0,ans = 0,last = 0;\n    std::pair&lt;int,int&gt; res;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    for(int i = 1 ; i &lt;= n + 1; i++)\n    {\n        if(a[i] == 0||i == n + 1)\n        {\n            int t = 0;\n            if(cnt_negative&amp;1)\n            {\n                for(int j = last + 1 ; j &lt; i ; j++)\n                {\n                    if(a[j] == 2||a[j] == -2)t++;\n                    if(a[j] &lt; 0)\n                    {\n                        if(cnt_two - t &gt; ans)\n                        {\n                            ans = cnt_two - t;\n                            res = {j, n + 1 - i};\n                        }\n                        break;\n                    }\n                }\n                t = 0;\n                for(int j = i - 1; j &gt; last ; j--)\n                {\n                    if(a[j] == 2||a[j] == -2)t++;\n                    if(a[j] &lt; 0)\n                    {\n                        if(cnt_two - t &gt; ans)\n                        {\n                            ans = cnt_two - t;\n                            res = {last,n + 1 - j};\n                        }\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                if(cnt_two &gt; ans)\n                {\n                    ans = cnt_two;\n                    res = {last,n + 1 - i};\n                }\n            }\n            last = i;\n            cnt_negative = cnt_two = 0;\n        }\n        else\n        {\n            if(a[i] == 2)cnt_two++;\n            else if(a[i]==-2)cnt_two++,cnt_negative++;\n            else if(a[i]==-1)cnt_negative++;\n        }\n    }\n    if(ans == 0)std::cout&lt;&lt;n&lt;&lt;\" \"&lt;&lt;0&lt;&lt;'\\n';\n    else std::cout&lt;&lt;res.first&lt;&lt;\" \"&lt;&lt;res.second&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nE. Matrix and Shifts题意：\n\n\n\n\n\n\n\n\n\n有一个的矩阵，里面的每个元素都是0和1，可以任意执行以下4种操作(无需任何代价)：\n\n\n全体上移一行(第一行到最后一行)\n全体下移一行(最后行到第一行)\n全体左移一行(最左边一行到最右边一行)\n全体右移一行(最右边一行到最左边一行)\n\n操作完后，我们可以花费一个代价，执行这样的操作：\n\n\n\n\n\n\n\n\n\n把某个元素从0变成1，或者从1变成0。\n要求变完以后，只有对角线元素是1，其余均是0。输出最小代价。\n\n思路：\n\n\n\n\n\n\n\n\n\n我们只要让尽可能多的1落在对角线上就可以了。即以如下方式遍历矩阵：\n\n\n记录下 1 最多的数量 。那么最后要修改的数量就是：\n\n在对角线上的 0 元素()\n不在对角线上的 1 元素()\n\n记录矩阵中 1 的个数为：所以最终答案为\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e3+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N][N];\n\nvoid solve()\n{\n    int n,cnt = 0,max = 0;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        std::string s;\n        std::cin&gt;&gt;s;\n        for(int j = 1 ; j &lt;= n ; j++)\n        {\n            a[i][j] = s[j-1] - '0';\n            cnt += (a[i][j] == 1);\n        }\n    }\n    for(int j = 1 ; j &lt;= n ; j++)\n    {\n        int y = j,temp = 0;\n        for(int i = 1 ; i &lt;= n ; i++)\n        {\n            if(a[i][y] == 1)temp++;\n            y++;\n            if(y==n+1)y = 1;\n        }\n        max = std::max(max,temp);\n    }\n    std::cout&lt;&lt;cnt - max + (n - max)&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nF1. Promising String (easy version)题意：\n\n\n\n\n\n\n\n\n\n给定一个由’+’和‘-’组成的字符串S，定义有希望的字符串如下：\n\n字符串可以进行如下操作：\n\n相邻的两个’-‘可以合并为’+’\n可以通过上述操作，使得字符串中’+’和‘-’的数量相同。\n\n输出字符串S中所有满足条件的子串的个数。\n\n思路：\n\n\n\n\n\n\n\n\n\n因为数据量只有3000，所以我们直接暴力枚举所有区间。检查区间合法的方法如下：\n\n\n记录下区间中‘+‘的数量cnt1，‘-‘的数量cnt0，以及可以合并的减号的最大对数cnt。\n假设合并的减号对数为:\n$cnt_{0}-2x=cnt_{1}+xcnt_{0}-cnt_{1}=3x$\n\n\n那么只需要满足为整数，而且，区间就是合法的。\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e3+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    std::string s;\n    std::cin&gt;&gt;s;\n    bool tag = false;\n    int cnt1,cnt0,cnt,res = 0;\n    for(int i = 0 ; i &lt; n ; i++)\n    {\n        cnt = 0,cnt1 = 0,cnt0 = 0;\n        for(int j = i ; j &lt; n ; j++)\n        {\n            if(s[j] == '+')cnt1++,tag = false;\n            else\n            {\n                if(tag)\n                {\n                    cnt++;\n                    cnt0++;\n                    tag = false;\n                }\n                else\n                {\n                    cnt0++;\n                    tag = true;\n                }\n            }\n            if(cnt0==cnt1)res++;\n            else\n            {\n                if(cnt0 &gt; cnt1 &amp;&amp; (cnt0 - cnt1) % 3 == 0)\n                {\n                    if(cnt &gt;= (cnt0 - cnt1)/3 )res++;\n                }\n            }\n        }\n    }\n    std::cout&lt;&lt;res&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n","slug":"Codeforces-Round-780-Div-3","date":"2022-04-12T10:34:26.000Z","categories_index":"Codeforces","tags_index":"algorithm","author_index":"Aurora"},{"id":"125917e35db77b388a3d8bf4e666f8ce","title":"Codeforces Round 779 (Div. 2)(Permutationforces)","content":"@[toc]\nA. Marin and Photoshoot题意：\n\n\n\n\n\n\n\n\n\n给定一个由0和1组成的序列，现在可以往这个序列中添加1，是的这个序列满足如下要求：对于任意长度大于等于2的区间，要求这个区间中1的个数大于等于0的个数。\n思路：\n\n\n\n\n\n\n\n\n\n添加1，使得序列中不存在如下情况：00或者010即保证两个0之间的距离大于等于2。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nvoid solve()\n{\n    int n;\n    std::string s;\n    std::cin&gt;&gt;n&gt;&gt;s;\n    int res = 0,last = -1;\n    for(int i = 0 ; i &lt; n ; i++)\n    {\n        if(s[i]=='0')\n        {\n            if(last==-1)last = i;\n            else\n            {\n                if(i-last&lt;=2)res += 3 - (i - last);\n                last = i;\n            }\n        }\n    }\n    std::cout&lt;&lt;res&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nB. Marin and Anti-coprime Permutation题意：\n\n\n\n\n\n\n\n\n\n要求构造一个长度为n的全排列，满足如下要求：$gcd(1p_{1},2p_{2},\\dots n-1p_{n-1},np_{n}) &gt; 1$询问有几种方案满足上述要求。\n思路：\n\n\n\n\n\n\n\n\n\n选取任意的k，那么存在k的因子的数必然k的倍数。因此不难推知n个数里面包含k的因子的数有个，那么加上要乘的数，所以包含k的因子的个数应该是$2\\left \\lceil \\frac{n}{k} \\right \\rceil个。我们我保证2\\left \\lceil \\frac{n}{k} \\right \\rceil \\geq n，因此只能取。那么就让所有的数相乘后为偶数，即让奇数乘偶数位，偶数乘奇数位即可。若为偶数结果为(\\frac{n}{2})!*(\\frac{n}{2})!$2.若n为奇数，结果为0。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 998244353 ;\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    ll res = 1;\n    if(n&amp;1)\n    {\n        std::cout&lt;&lt;0&lt;&lt;'\\n';\n        return;\n    }\n    for(int i = 1 ; i &lt;= n/2 ; i++)\n        res = (i*res) % mod;\n    std::cout&lt;&lt;res*res%mod&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nC. Shinju and the Lost Permutation题意：\n\n\n\n\n\n\n\n\n\n给定一个全排列：再由这个全排列可以得到另一个数组a定义 c 为数组a中不同数的个数，并称 c 是数组 a 的幂。那么我们把这个数组p全体向右移动一个单位，这样又可以确定一个数组a，进而确定 c 的值。我们让表示全排列向右移动次的值。现给定数组，询问能否存在全排列，使得移动次的值等于。\n思路：\n\n\n\n\n\n\n\n\n\n产生的数组 c 要满足如下要求：1.移动过程中，我们考虑当最大数移动到第一个位置时，此时的 c 必然是 1，且只有这种情况 c 为 1。2.将1中的全排列向右移动一个单位，此时 c 必然是 2。3.那么在之后的移动过程中，c 每次最多可以增加 1(要注意，最大数以后的数必然只能为 c 提供 1 的 贡献)，或者可以减小若干。因此，我们只需要判断 c 是否满足如下情况：1.c = 1 应该有且只有一个。2.从1的位置开始判断，每次最多只会增加1，或者减小若干。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 998244353 ;\n\nint a[N];\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    int index = -1,cnt = 0;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        std::cin&gt;&gt;a[i];\n        if(a[i] == 1)index = i,cnt++;\n    }\n    if(index==-1||cnt&gt;1)\n    {\n        std::cout&lt;&lt;\"NO\\n\";\n        return;\n    }\n    for(int i = 1 ; i &lt; n ; i++)\n    {\n        int x = index + 1;\n        if(x==n+1)x = 1;\n        if(a[x] - a[index] &gt;= 2)\n        {\n            std::cout&lt;&lt;\"NO\\n\";\n            return;\n        }\n        index++;\n        if(index==n+1)index = 1;\n    }\n    std::cout&lt;&lt;\"YES\\n\";\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nD1. 388535 (Easy Version)题意：\n\n\n\n\n\n\n\n\n\n给定从L(L = 0)到R的一个全排列和一个整数 x 。现在对这个全排列的每个数都执行如下操作：给出操作完后的数组，询问是否存在 x 。\n思路：\n\n\n\n\n\n\n\n\n\n因为全排列是从0开始，我们可以发现在每一位数字上0的个数必然大于等于1的个数，因此我们我们只要保证这一条件即可构造出答案 x ：对于第  位，我们构造如下：1.若，该位取12.若，该位取0\n举例：0~700000001001000110100010101100111每一位上显然有。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 998244353 ;\n\nint a[20][2];\n\nvoid solve()\n{\n    int l,r;\n    std::cin&gt;&gt;l&gt;&gt;r;\n    memset(a,0,sizeof a);\n    for(int i = 1 ; i &lt;= r - l + 1 ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        for(int j = 0 ; j &lt;= 17 ; j++)a[j][x&gt;&gt;j&amp;1]++;\n    }\n    int res = 0;\n    for(int i = 0 ; i &lt;= 17 ; i++)\n    {\n        if(a[i][1] &gt; a[i][0])res += 1 &lt;&lt; i;\n    }\n    std::cout&lt;&lt;res&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n","slug":"Codeforces-Round-779-Div-2-Permutationforces","date":"2022-04-12T10:33:55.000Z","categories_index":"Codeforces","tags_index":"algorithm","author_index":"Aurora"},{"id":"e46a6dad08206a9d3e04ebe2b2c5fc2a","title":"CodeTON Round 1 (Div. 1 + Div. 2, Rated, Prizes)","content":"\n@[toc] \nA. Good Pairs题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为n的序列：现在要找到一对下标满足：对所有的成立\n思路：\n\n\n\n\n\n\n\n\n\n显然只要和是最大值是最小值即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码:\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    std::cout&lt;&lt;std::max_element(a+1,a+1+n) - a&lt;&lt;\" \"&lt;&lt;std::min_element(a+1,a+1+n)-a&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nB. Subtract Operation题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为n的序列：。现在可以从中选择一个，将其删除，并让其余所有数减：。执行这样的操作若干次，直至序列中只剩下一个数。是否存在某种操作顺序，可以使最后剩下的数等于k。\n思路：\n\n\n\n\n\n\n\n\n\n假设最后留下的数是，最后一次删除的数是（原序列中的和），那么最后留下来的数为。\n证明如下：设第次删除了，得到：。设第次删除了，得到：。。\n因此，整个序列减小的数只与最后一次删除有关。最终留下的数即。那么我们只需要寻找是否存在这样的一对数，满足即可。这里在排序后二分就可以完成查找。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nvoid solve()\n{\n    int n,k;\n    std::cin&gt;&gt;n&gt;&gt;k;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    std::sort(a+1,a+1+n);\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int index = std::lower_bound(a+1,a+n+1,a[i]+k) - a;\n        if(index &lt;= n &amp;&amp; a[index] - a[i] == k)\n        {\n            std::cout &lt;&lt; \"YES\\n\";\n            return;\n        }\n    }\n    std::cout&lt;&lt;\"NO\\n\";\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\nC. Make Equal With Mod题意：\n\n\n\n\n\n\n\n\n\n给定一个序列：。选择一个数，对所有数取模：。在若干次操作后是否可能使所有数相等。\n思路：\n\n\n\n\n\n\n\n\n\n第一种情况，原序列没有1：我们考虑把所有数变成0，即每次选择最大的数，令,则一次操作后只有最大的数变成0，其余数均不变。所以该情况一定有解。\n第一种情况，原序列存在1：那么我们只能考虑把所有数变成1。每次选择最大的数，令，那么取模后最大数变成1。若在此过程中序列中存在，则变成 0 ，那么不存在方案。否则存在方案。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    bool flag = false;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        flag = (a[i]==1);\n        if(flag)break;\n    }\n    if(!flag)\n    {\n        std::cout&lt;&lt;\"YES\\n\";\n    }\n    else\n    {\n        flag = false;\n        std::sort(a+1,a+1+n);\n        for(int  i = 1 ; i &lt; n ; i++)\n        {\n            flag = (a[i+1] - a[i] == 1);\n            if(flag)break;\n        }\n        if(flag)\n        {\n            std::cout&lt;&lt;\"NO\\n\";\n        }\n        else\n        {\n            std::cout&lt;&lt;\"YES\\n\";\n        }\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n \nE. Equal Tree Sums题意：\n\n\n\n\n\n\n\n\n\n给定一个无根树，每个节点有一个权值，现在我们要对节点分配一个权值，使得无论删除哪一个点，剩余的每个连通块权值之和相等。\n思路：\n\n\n\n\n\n\n\n\n\n从一个点开始遍历整棵树，起点染为白色。在遍历的时候，与白色相邻的点染为黑色，与黑色相邻的点染为白色。染色完成后，设每个点的度数为，并令：1.白色点的权值为2.黑色点的权值为赋值显然后所有整棵树的权值和为0，并且每条边对权值和的贡献为0。\n我们可以把一条边分裂成两条边，一条由黑色点指向白色点，权值为1，一条由白色点指向黑色点，权值为-1，那么一个白色点的权值就是由所有这个白色点指向黑色点的边加和而成。\n现在证明删除一个点后剩余连通块权值和相等：1.假设删除了一个黑点，权值为2.那么很显然此时有连通块3.现在我们根据上面的分边，为每个点重新赋值，那么每个连通块内部权值都为04.对于所有与黑点相连的白色点，权值相差的只是与黑点相连的这一条边的权值，其余所有点权值不变。5.所以实际上每个连通块变化的和都是一样的，为或。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(n+m)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint h[N],e[M],ne[M],idx;\nint w[N],d[N];\nbool color[N];\n\nvoid add(int a,int b)\n{\n    e[idx] = b,ne[idx] = h[a],h[a] = idx++;\n}\n\nvoid dfs(int u,int fa,bool st)\n{\n    color[u] = st;\n    for(int i = h[u] ; ~i ; i = ne[i])\n    {\n        int v = e[i];\n        d[u]++;\n        if(v==fa)continue;\n        dfs(v,u,st^1);\n    }\n}\n\nvoid solve()\n{\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)h[i] = -1,d[i] = 0;\n    idx = 0;\n    for(int i = 1 ; i &lt; n ; i++)\n    {\n        int a,b;\n        std::cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    }\n    dfs(1,-1,false);\n    for(int i = 1 ; i &lt;= n ; i++)color[i] == 0 ? std::cout&lt;&lt;-d[i]&lt;&lt;\" \":std::cout&lt;&lt;d[i]&lt;&lt;\" \";\n    std::cout&lt;&lt;'\\n';\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int T;\n    std::cin&gt;&gt;T;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}\n\n \n","slug":"CodeTON-Round-1-Div-1-Div-2-Rated-Prizes","date":"2022-04-12T10:33:21.000Z","categories_index":"Codeforces","tags_index":"algorithm","author_index":"Aurora"},{"id":"75e163e1709c0c17a44785b1605f0bc1","title":"AtCoder Beginner Contest 245","content":"\n@[toc]\nA - Good morning题意：\n\n\n\n\n\n\n\n\n\n语法题：给定两个起床时间。若第一个早于等于第二个，输出，反之输出。\n思路：\n\n\n\n\n\n\n\n\n\n见代码\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e2+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int a,b,c,d;\n    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;\n    if(a*60+b&lt;=c*60+d)std::cout&lt;&lt;\"Takahashi\";\n    else std::cout&lt;&lt;\"Aoki\";\n\n    return 0;\n}\nB - Mex题意：\n\n\n\n\n\n\n\n\n\n给定一个长度为n的序列，输出这个序列中未出现的最小自然数。\n思路：\n\n\n\n\n\n\n\n\n\n用一个数组统计数字出现次数，然后寻找这个序列中未出现的最小自然数。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e3+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint cnt[N];\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n;\n    std::cin&gt;&gt;n;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        cnt[x]++;\n    }\n    for(int i = 0 ; ; i++)\n    {\n        if(!cnt[i])\n        {\n            std::cout&lt;&lt;i;\n            return 0;\n        }\n    }\n    return 0;\n}\nC - Choose Elements题意：\n\n\n\n\n\n\n\n\n\n给定两个序列和一个整数k：要求构造出一个序列：或使得对于有:\n思路：\n\n\n\n\n\n\n\n\n\n如果对于都满足如上要求。那么显然此时是否满足要求只与有关。这种性质满足无后效性，考虑使用动态规划。我们设有：若表示第可用若表示第不可用若表示第可用若表示第不可用(这里可能用1表示可用更好，但是当时我不想初始化)即可以按如下方式转移：for(int i = 2 ; i &lt;= n ; i++)\n   {\n       if(!dp[i-1][0]&amp;&amp;abs(a[i]-a[i-1])&lt;=k||!dp[i-1][1]&amp;&amp;abs(a[i]-b[i-1])&lt;=k)dp[i][0] = 0;\n       else dp[i][0] = 1;\n       if(!dp[i-1][0]&amp;&amp;abs(b[i]-a[i-1])&lt;=k||!dp[i-1][1]&amp;&amp;abs(b[i]-b[i-1])&lt;=k)dp[i][1] = 0;\n       else dp[i][1] = 1;\n   }那么最后或存在一个可用即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(n)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N],b[N],dp[N][2];\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n,k;\n    std::cin&gt;&gt;n&gt;&gt;k;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;a[i];\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;b[i];\n    for(int i = 2 ; i &lt;= n ; i++)\n    {\n        if(!dp[i-1][0]&amp;&amp;abs(a[i]-a[i-1])&lt;=k||!dp[i-1][1]&amp;&amp;abs(a[i]-b[i-1])&lt;=k)dp[i][0] = 0;\n        else dp[i][0] = 1;\n        if(!dp[i-1][0]&amp;&amp;abs(b[i]-a[i-1])&lt;=k||!dp[i-1][1]&amp;&amp;abs(b[i]-b[i-1])&lt;=k)dp[i][1] = 0;\n        else dp[i][1] = 1;\n    }\n    if(!dp[n][0]||!dp[n][1])std::cout&lt;&lt;\"Yes\";\n    else std::cout&lt;&lt;\"No\";\n    return 0;\n}\nD - Polynomial division题意：\n\n\n\n\n\n\n\n\n\n存在多项式：将两个多项式相乘得到：现在给出所有系数和，请输出所有的。\n思路:\n\n\n\n\n\n\n\n\n\n开始时，有，并做如下处理：$c[i]=c[i]-b[0]ai。处理完后显然有b[1]=\\frac{c[1]}{a[0]}，并重复上述处理：c[i+1]=c[i+1]-b[1]ai。因此我们可以重复上述步骤直至求出所有b_{j}(0\\leq j\\leq n)b[j]=\\frac{c[j]}{a[0]}c[i+j]=c[i+j]-b[j]*a[i]$。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N],b[N],c[N];\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int n,m;\n    std::cin&gt;&gt;n&gt;&gt;m;\n    for(int i = n ; i &gt;= 0 ; i--)std::cin&gt;&gt;a[i];\n    for(int i = m + n; i &gt;= 0 ; i--)\n    {\n        std::cin&gt;&gt;c[i];\n    }\n    for(int i = 0 ; i &lt;= m ; i++)\n    {\n        b[i] = c[i]/a[0];\n        for(int j = 1 ; j &lt;= n ; j++)\n        {\n            c[i+j] -= (b[i] * a[j]);\n        }\n    }\n    for(int i = m ; i &gt;= 0 ; i--)std::cout&lt;&lt;b[i]&lt;&lt;\" \";\n    return 0;\n}\nE - Wrapping Chocolate\n\n\n\n\n\n\n\n\n题意：有n个巧克力，宽度为，长度为。有m个盒子，宽度为，长度为。如果，那么第盒子就可以装下第个巧克力。询问是否存在一种方案，可以用盒子把所有的巧克力装下。\n思路：\n\n\n\n\n\n\n\n\n\n没看数据之前，还想着暴力跑二分图最大匹配无序查找必然超时，考虑对某个关键字排序。我们把巧克力和盒子一起按照宽度降序排序(如果宽度相同则把盒子排在前面)，遍历排序后的数组，并维护一个集合S，按照如下方式处理：1.如果当前位置为盒子：将长度加入集合。2.如果当前位置为巧克力：找到，并将删除，如果查找失败，则不存在方案。易证明上述操作可以完成题目要求，上述操作可以用multiset完成。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(nlogn)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 4e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y;\n    bool box;\n    bool operator&lt;(const Node &amp;a)const\n    {\n        if(a.x == x)return a.box &lt; box;\n        return a.x &lt; x;\n    }\n}a[N];\nstd::multiset&lt;int&gt; st;\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n,m;\n    std::cin&gt;&gt;n&gt;&gt;m;\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        a[i].x = x;\n    }\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        a[i].y = x;\n        a[i].box = false;\n    }\n    for(int i = n + 1 ; i &lt;= m + n; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        a[i].x = x;\n    }\n    for(int i = n + 1 ; i &lt;= m + n ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        a[i].y = x;\n        a[i].box = true;\n    }\n    std::sort(a+1,a+1+n+m);\n    for(int i = 1 ; i &lt;= n + m; i++)\n    {\n        if(a[i].box)\n        {\n            st.insert(a[i].y);\n        }\n        else\n        {\n            auto it = st.lower_bound(a[i].y);\n            if(it!=st.end())st.erase(it);\n            else\n            {\n                std::cout&lt;&lt;\"No\";\n                return 0;\n            }\n        }\n    }\n    std::cout&lt;&lt;\"Yes\";\n    return 0;\n}\nF - Endless Walk题意：\n\n\n\n\n\n\n\n\n\n给定一张有向图，寻找这样的点，满足如下要求：从这个点出发，存在一条无限长的路径。输出有几个点满足上述要求。\n思路：\n\n\n\n\n\n\n\n\n\n满足上述的点存在两种情况：1.该点在环内2.从这个点出发可以走到环我的处理可能复杂些，按照如下步骤：1.强连通分量跑tarjan缩点，对于任意的强连通分量，若内部点数，则这些点都在环内。2.若选择这样的做法，细节较多：从其他点开始搜索，尝试是否能走到环。尝试采用另一种方法：建立反向图，从环开始搜索，对于所有搜索到的点，都满足要求。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(n+m)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint h[N],hs[N],e[M],ne[M],idx;\nint id[N],dfn[N],low[N],stk[N],size[N],scc,top,ts;\nbool book[N],vis[N],OK[N];\nint res;\n\nvoid add(int h[],int a,int b)\n{\n    e[idx] = b,ne[idx] = h[a],h[a] = idx++;\n}\n\nvoid tarjan(int u)\n{\n    dfn[u] = low[u] = ++ts;\n    book[u] = true,stk[++top] = u;\n    for(int i = h[u] ; ~i ; i = ne[i])\n    {\n        int v = e[i];\n        if(!dfn[v])\n        {\n            tarjan(v);\n            low[u] = std::min(low[u],low[v]);\n        }\n        else if(book[v])low[u] = std::min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        int temp;\n        scc++;\n        do{\n            temp = stk[top--];\n            book[temp] = false;\n            id[temp] = scc;\n            size[scc]++;\n        }while(temp!=u);\n    }\n}\n\nvoid dfs(int u)\n{\n    res++,vis[u] = OK[u] = true;\n    for(int i = hs[u] ; ~i ; i = ne[i])\n    {\n        int v = e[i];\n        if(vis[v])continue;\n        dfs(v);\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    memset(h,-1,sizeof h);\n    memset(hs,-1,sizeof hs);\n    int n,m;\n    std::cin&gt;&gt;n&gt;&gt;m;\n    while(m--)\n    {\n        int a,b;\n        std::cin&gt;&gt;a&gt;&gt;b;\n        add(h,a,b),add(hs,b,a);\n    }\n    for(int i = 1 ; i &lt;= n ; i++)if(!dfn[i])tarjan(i);\n    for(int i = 1 ; i &lt;= n ; i++)\n        if(size[id[i]] &gt; 1)OK[i] = true;\n    for(int i = 1 ; i &lt;= n ; i++)if(OK[i]&amp;&amp;!vis[i])dfs(i);\n    std::cout&lt;&lt;res;\n    return 0;\n}\nG - Foreign Friends题意：\n\n\n\n\n\n\n\n\n\n现有N个人，这些人属于K个国家，这N个人中有L个人是受欢迎的人，这L个人分别属于不同的国家。小明是个中间人，存在M对关系：小明可以让某一对中的两个人相互认识，但是要花费一定的金额。对于这N个人中的每一个人，他们都想要认识一个不在自己国家的受欢迎的人,分别输出这N个人所需的最小花费。(若a认识b，b认识c，那么有a认识c)\n思路：\n\n\n\n\n\n\n\n\n\n比较显然的，这是一个最短路问题,可以使用Dijkstra(使用优先队列)。正向考虑跑最短路显然不行，我们反向考虑让每个受欢迎的人去认识每一个人，但是我们如果让每个受欢迎的人去跑最短路，时间复杂度也会达到，但是这题比较特殊，我们可以进行如下考虑：1.我们把所有受欢迎的人放在优先队列里同时跑最短路，并记录他们所属的国家,在这个过程中我们通过记录，保证每个国家只会更新一次。2.那么当人被第一次和第二次取出的时候，所需的花费分别是最小，次小的，并且更新这两次的国家不同。因为只会属于一个国家，所以这两个最小数中一定有一个和自己的国家不同。3.如果与更新最小值的国家不同，输出最小值即可，反之输出次小值。\n时间复杂度：\n\n\n\n\n\n\n\n\n\nO(nlogn)\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 4,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    ll dist;\n    int u,city;\n    bool operator &lt;(const Node &amp;a)const\n    {\n        return a.dist &lt; dist;\n    }\n};\nint h[N],e[N],ne[N],w[N],idx;\nint vis[N],city[N],type[N];\nll dist1[N],dist2[N];\nint n,m,k,l;\nstd::priority_queue&lt;struct Node&gt; que;\n\nvoid add(int a,int b,int c)\n{\n    e[idx] = b,ne[idx] = h[a],w[idx] = c,h[a] = idx++;\n}\n\nvoid Dijkstra()\n{\n    while(!que.empty())\n    {\n        auto temp = que.top();\n        que.pop();\n        if(vis[temp.u] &lt; 2 &amp;&amp; type[temp.u] != temp.city)\n        {\n            if(vis[temp.u] == 0) type[temp.u] = temp.city,dist1[temp.u] = temp.dist;\n            else dist2[temp.u] = temp.dist;\n            vis[temp.u]++;\n            for(int i = h[temp.u] ; ~i ; i = ne[i])\n            {\n                int v = e[i];\n                que.push({temp.dist+w[i],v,temp.city});\n            }\n        }\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    memset(h,-1,sizeof h);\n    std::cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;l;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;city[i];\n    for(int i = 1 ; i &lt;= l ; i++)\n    {\n        int x;\n        std::cin&gt;&gt;x;\n        que.push({0ll,x,city[x]});\n    }\n    while(m--)\n    {\n        int a,b,c;\n        std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        add(a,b,c),add(b,a,c);\n    }\n    Dijkstra();\n    for(int i = 1 ; i &lt;= n ; i++)\n    {\n        if(type[i] != city[i]&amp;&amp;dist1[i])std::cout&lt;&lt;dist1[i]&lt;&lt;\" \";\n        else if(dist2[i])std::cout&lt;&lt;dist2[i]&lt;&lt;\" \";\n        else std::cout&lt;&lt;-1&lt;&lt;\" \";\n    }\n    return 0;\n}\n","slug":"AtCoder-Beginner-Contest-245","date":"2022-04-12T10:32:05.000Z","categories_index":"Atcoder","tags_index":"algorithm","author_index":"Aurora"},{"id":"3e603a5ebaa3bb11ce97c7711a41ebdb","title":"AtCoder Beginner Contest 246","content":"\n@[toc]\n\nA - Four Points题意：\n\n\n\n\n\n\n\n\n\n给出三个点，找到一个点，让这4个点组成一个矩形\n思路：\n\n\n\n\n\n\n\n\n\n分别找到横纵坐标中只有一个的值。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e2+5,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int x,y,ans_x = 0,ans_y = 0;\n    for(int i = 1 ; i &lt;= 3 ; i++)\n    {\n        std::cin&gt;&gt;x&gt;&gt;y;\n        ans_x ^= x,ans_y ^= y;\n    }\n    std::cout&lt;&lt;ans_x&lt;&lt;' '&lt;&lt;ans_y;\n    return 0;\n}\n\n\nB - Get Closer题意：\n\n\n\n\n\n\n\n\n\n给出一个向量，将其变成单位向量。\n思路：\n\n\n\n\n\n\n\n\n\n将向量除以他的模即可。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e2+5,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    double x,y;\n    scanf(\"%lf%lf\",&amp;x,&amp;y);\n    printf(\"%.10f %.10f\",x / sqrt(x*x+y*y),y / sqrt(x*x+y*y));\n    return 0;\n}\n\n\nC - Coupon题意：\n\n\n\n\n\n\n\n\n\n给定n个商品，每个商品的价格是，现在有k张优惠券，每张优惠券可以减少某个商品x元(不得低于0)，询问购买全部商品的最小花费。\n思路：\n\n\n\n\n\n\n\n\n\n先保证不浪费优惠券的情况下，把尽可能多的商品价格减免到x元以下，然后如果还有优惠券剩余，我们对剩下的商品价格从高到低使用优惠券。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\nint a[N];\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    int n,k,x;\n    std::cin&gt;&gt;n&gt;&gt;k&gt;&gt;x;\n    for(int i = 1; i &lt;= n ; i++)\n    {\n        std::cin&gt;&gt;a[i];\n        if(k == 0)continue;\n        if(k &gt;= a[i]/x)\n        {\n            k -= a[i]/x;\n            a[i] %= x;\n        }\n        else\n        {\n            a[i] -= k * x;\n            k = 0;\n        }\n    }\n    ll sum = 0;\n    std::sort(a+1,a+1+n,std::greater&lt;int&gt;());\n    for(int i = 1 + k ; i &lt;= n ; i++)sum += a[i];\n    std::cout&lt;&lt;sum;\n    return 0;\n}\n\n\nD - 2-variable Function题意：\n\n\n\n\n\n\n\n\n\n给定一个数n，找到一个数x，满足下列两个条件：\n\n\n\n使得\n\n\n思路：\n\n\n\n\n\n\n\n\n\n我们可以使用双指针，从小到大枚举，从大到小，从而枚举出所有的，并从中找到最小值。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1500+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\n\n\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    ll n;\n    std::cin&gt;&gt;n;\n    ll res = 1e18;\n    ll j = 1e6;\n    for(ll i = 0 ; i &lt;= 1e6 ; i++)\n    {\n        ll temp = i*i*i+i*i*j+i*j*j+j*j*j;\n        while(temp &gt;= n &amp;&amp; j &gt;= 0)\n        {\n            res = std::min(res,temp);\n            j--;\n            temp = i*i*i+i*i*j+i*j*j+j*j*j;\n        }\n    }\n    std::cout&lt;&lt;res;\n    return 0;\n}\n\n\nE - Bishop 2题意：\n\n\n\n\n\n\n\n\n\n给出一个的地图，其中是平地，其中#是障碍，并给出一个起点和终点，在不跨越障碍的情况下，可以往左上，右上，右下，左下四个斜角方向一次移动任意个单位，询问从起点移动到终点的最小步数，若不存在路径，则输出-1。\n思路：\n\n\n\n\n\n\n\n\n\n修改正常BFS的拓展方式即可，每次拓展的时候把四个斜角方向可以拓展的点全部拓展。\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1500+10,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;\nstruct Node{\n    int x,y,step;\n}que[N*N];\nchar a[N][N];\nbool book[N][N];\nint ne[4][2] = {1,1,1,-1,-1,1,-1,-1};\nint n,start_x,start_y,end_x,end_y;\n\nbool OK(int x,int y)\n{\n    if(x&lt;1||y&lt;1||x&gt;n||y&gt;n||a[x][y]=='#')return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int head = 0,tail = -1;\n    que[++tail] = {start_x,start_y,0};\n    book[start_x][start_y] = true;\n    while(tail&gt;=head)\n    {\n        auto temp = que[head++];\n        if(temp.x == end_x &amp;&amp; temp.y == end_y)\n        {\n            std::cout&lt;&lt;temp.step;\n            return;\n        }\n        for(int i = 0 ; i &lt; 4 ; i++)\n        {\n            int tx = temp.x + ne[i][0];\n            int ty = temp.y + ne[i][1];\n            while(OK(tx,ty))\n            {\n                if(!book[tx][ty])que[++tail] = {tx,ty,temp.step+1};\n                book[tx][ty] = true;\n                tx += ne[i][0];\n                ty += ne[i][1];\n            }\n        }\n    }\n    std::cout&lt;&lt;-1;\n}\n\nint main()\n{\n//    std::ios::sync_with_stdio(false);\n//    std::cin.tie(nullptr);\n//    std::cout.tie(nullptr);\n    std::cin&gt;&gt;n&gt;&gt;start_x&gt;&gt;start_y&gt;&gt;end_x&gt;&gt;end_y;\n    for(int i = 1 ; i &lt;= n ; i++)std::cin&gt;&gt;(a[i]+1);\n    bfs();\n    return 0;\n}\n\n\nF - typewriter题意：\n\n\n\n\n\n\n\n\n\n给出n个键盘，每个键盘可以打印字母由一个字符串表示，现在要打印一个长度为L的字符串，每次选择一个键盘打印字符串，可以打印出多少不同的字符串。\n思路：\n\n\n\n\n\n\n\n\n\n应用容斥原理，以n=3为例：\n\nans =+（只使用第一个键盘）+（只使用第二个键盘）+（只使用第三个键盘）-（只使用第一个键盘和第二个键盘共有的字母打印）-（只使用第一个键盘和第三个键盘共有的字母打印）-（只使用第二个键盘和第三个键盘共有的字母打印）+（使用所用键盘共有的字母打印）。\n因此我们只需要枚举上述所有情况，求出答案即可。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\nN个字母所能打印的长度为L的字符串的个数为。使用快速幂会花费的时间。此外，枚举所有的情况是所以总时间复杂度为\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 30,M = 2e4+10,INF = 0x3f3f3f3f,mod = 998244353;\n\nbool temp[N],a[N][N];\nll ans,n,len;\n\nll quickPow(ll x,ll k)\n{\n    ll res = 1;\n    while(k)\n    {\n        if(k&amp;1)res = (x * res) % mod;\n        x = x * x % mod;\n        k &gt;&gt;= 1;\n    }\n    return res;\n}\n\nvoid dfs(int u,int cnt)\n{\n    if(u==n)\n    {\n        if(cnt==0)return;\n        int count = 0;\n        for(int i = 0 ; i &lt; 26 ; i++)if(temp[i])count++;\n        if(cnt&amp;1)ans = (ans + quickPow(count,len)) % mod;\n        else ans = (ans - quickPow(count,len) + mod) % mod;\n        return;\n    }\n    dfs(u+1,cnt);\n    bool last[N];\n    memcpy(last,temp,sizeof temp);\n    for(int i = 0 ; i &lt; 26 ; i++)temp[i] &amp;= a[u][i];\n    dfs(u+1,cnt+1);\n    memcpy(temp,last,sizeof temp);\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::cin&gt;&gt;n&gt;&gt;len;\n    for(int i = 0 ; i &lt; n ; i++)\n    {\n        std::string s;\n        std::cin&gt;&gt;s;\n        for(int j = 0 ; j &lt; s.size() ; j++) a[i][s[j]-'a'] = true;\n    }\n    for(int i = 0 ; i &lt; 26 ; i++)temp[i] = true;\n    dfs(0,0);\n    std::cout&lt;&lt;ans;\n    return 0;\n}\n\nG - Game on Tree 3题意：\n\n\n\n\n\n\n\n\n\n给定一棵根为1的树，除了根，每个点都有一个权值，现在小明和小红从根节点开始按照如下规则玩一个游戏：\n\n\n小红任意选择一个点，把这个点的权值变为0\n小明从当前点出发，可以走到任意一个儿子节点\n然后小明可以决定是否结束游戏(如果小明在叶子节点则必须结束游戏)\n\n最后小明获得的分数就是小明所在点的权值，小明希望获得的分数尽可能得高，小红希望小明获得的分数尽可能的低,假设两人都足够聪明的情况下(即总是做出对当前最有利的操作)，小明可以获得的最大分数是多少。\n\n思路：\n\n\n\n\n\n\n\n\n\n使用动态规划(树形dp)和二分答案。考虑对于某一个分数，小明是否存在方案可以获得比大的分数：\n\n我们令的点为1，的点为0，。如果要使小明无法获得分数，那么必须要使这些为1的点变成0，我们假设为小明在点开始游戏小红所需要的消除次数。那么对于某个点的，我们可以用如下式子求出：\n\n\n如果当前点,那么肯定是要消除的，在小明走到儿子节点之前，我们还有一次消除机会(开始游戏时小红是先手)，所以还要加上。\n最后可以求得，如果，那么小明是可以获得一个比大的分数的。\n\n最后用二分找到最大值即可。\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 2e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 998244353;\n\nint h[N],e[M],ne[M],idx;\nint w[N],dp[N];\n\nvoid add(int a,int b)\n{\n    e[idx] = b,ne[idx] = h[a],h[a] = idx++;\n}\n\nvoid dfs(int u,int fa,int val)\n{\n    dp[u] = (w[u] &gt;= val);\n    int sum = 0;\n    for(int i = h[u] ; ~i ; i = ne[i])\n    {\n        int v = e[i];\n        if(v==fa)continue;\n        dfs(v,u,val);\n        sum += dp[v];\n    }\n    dp[u] += std::max(0,sum-1);\n}\n\nbool check(int val)\n{\n    dfs(1,-1,val);\n    return dp[1] != 0;\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int n;\n    std::cin&gt;&gt;n;\n    memset(h,-1,sizeof h);\n    int max = -1;\n    for(int i = 2 ; i &lt;= n ; i++)std::cin&gt;&gt;w[i],max = std::max(max,w[i]);\n    for(int i = 1 ; i &lt; n ; i++)\n    {\n        int a,b;\n        std::cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    }\n    w[0] = -1;\n    int L = 0,R = max;\n    while(R&gt;L)\n    {\n        int mid = L + R + 1 &gt;&gt; 1;\n        if(check(mid))L = mid;\n        else R = mid - 1;\n    }\n    std::cout&lt;&lt;L;\n    return 0;\n}\n\nEx - 01? Queries题意：\n\n\n\n\n\n\n\n\n\n给定一个由和组成的字符串,我们可以任意得将替换成或,求字符串的所有子串可以形成的不同的01串有多少种。现在存在q个操作,每次操作将第x个字符变成或,询问每次操作后的答案。\n思路：\n\n\n\n\n\n\n\n\n\n我们先考虑在某种情况下的01串种数。考虑动态规划,定义和分别表示前个字母所能组成的以0结尾的和以1结尾的种数。那么应该有如下状态转移方程:\n\n\n\n\n\n\n我们将上述状态转移方程用矩阵表示:\n\n\n\n\n\n\n\n\n\n分别的,对于不同的,有:\n\n\n此外有\n我们可以用线段树维护每一个矩阵,这样修改操作可以在时间内完成。\n\n\n时间复杂度：\n\n\n\n\n\n\n\n\n\n\nAC代码：\n#include&lt;bits/stdc++.h&gt;\n\ntypedef long long ll;\n\nconst int N = 1e5+10,M = N * 2,INF = 0x3f3f3f3f,mod = 998244353;\nstruct Node{\n    int l,r;\n    ll a[3][3];\n}tr[N*4];\n\nchar s[N];\nint n,q;\n\nvoid pushup(int u)\n{\n    memset(tr[u].a,0,sizeof tr[u].a);\n    for(int i = 0 ; i &lt; 3 ; i++)\n        for(int j = 0 ; j &lt; 3 ; j++)\n        {\n            for(int k = 0 ; k &lt; 3 ; k++)\n                tr[u].a[i][j] = (tr[u].a[i][j] + tr[u&lt;&lt;1].a[i][k]*tr[u&lt;&lt;1|1].a[k][j])%mod;\n        }\n}\n\nvoid assign(Node &amp;root,char ch)\n{\n    if(ch=='0')\n    {\n        root.a[0][0] = 1;\n        root.a[0][1] = 1;\n        root.a[0][2] = 1;\n        root.a[1][0] = 0;\n        root.a[1][1] = 1;\n        root.a[1][2] = 0;\n        root.a[2][0] = 0;\n        root.a[2][1] = 0;\n        root.a[2][2] = 1;\n    }\n    else if(ch=='1')\n    {\n        root.a[0][0] = 1;\n        root.a[0][1] = 0;\n        root.a[0][2] = 0;\n        root.a[1][0] = 1;\n        root.a[1][1] = 1;\n        root.a[1][2] = 1;\n        root.a[2][0] = 0;\n        root.a[2][1] = 0;\n        root.a[2][2] = 1;\n    }\n    else\n    {\n        root.a[0][0] = 1;\n        root.a[0][1] = 1;\n        root.a[0][2] = 1;\n        root.a[1][0] = 1;\n        root.a[1][1] = 1;\n        root.a[1][2] = 1;\n        root.a[2][0] = 0;\n        root.a[2][1] = 0;\n        root.a[2][2] = 1;\n    }\n}\n\nvoid build(int u,int l,int r)\n{\n    if(l==r)\n    {\n        tr[u] = {l,r};\n        assign(tr[u],s[r]);\n    }\n    else\n    {\n        int mid = l + r &gt;&gt; 1;\n        tr[u] = {l,r};\n        build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r);\n        pushup(u);\n    }\n}\n\nvoid modify(int u,int x,char ch)\n{\n    if(tr[u].l==x&amp;&amp;tr[u].r==x)\n    {\n        assign(tr[u],ch);\n    }\n    else\n    {\n        int mid = tr[u].l + tr[u].r &gt;&gt; 1;\n        if(x &lt;= mid)modify(u&lt;&lt;1,x,ch);\n        else modify(u&lt;&lt;1|1,x,ch);\n        pushup(u);\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::cin&gt;&gt;n&gt;&gt;q;\n    std::cin&gt;&gt;(s+1);\n    build(1,1,n);\n    while(q--)\n    {\n        int x;\n        char ch;\n        std::cin&gt;&gt;x&gt;&gt;ch;\n        modify(1,x,ch);\n        std::cout&lt;&lt;(tr[1].a[0][2]+tr[1].a[1][2])%mod&lt;&lt;'\\n';\n    }\n    return 0;\n}\n\n","slug":"AtCoder-Beginner-Contest-246","date":"2022-04-12T09:34:16.000Z","categories_index":"Atcoder","tags_index":"algorithm","author_index":"Aurora"}]