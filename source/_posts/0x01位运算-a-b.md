---
title: 0x01位运算--a^b
date: 2022-04-14 12:57:50
tags:
categories:
- 算法进阶指南笔记
mathjax: true
---
## 0x01位运算——a^b
- 题目：
![](https://img-blog.csdnimg.cn/ad81ce79ced443249ac4864979d1ccb8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGltZXJfY2F0Y2g=,size_20,color_FFFFFF,t_70,g_se,x_16)
- 思路分析
>如果b在二进制下有k位,每一位为$C_{i}$
>可以将b分解为：
>1. $b=C_{k-1}*2^{k-1}+C_{k-2}*2^{k-2}+...+C_{0}*2^{0}$
>2. $因为2^{k-1}=(2^{k-2})^{2},所以很容易用递推求出每一个乘积项$

- 时间复杂度分析
>$k=\left \lceil log_{2}(b+1) \right \rceil，所以这样的项不会超过\left \lceil log_{2}(b+1) \right \rceil个$
>**时间复杂度**：$O(log_{2}(n))$

- 代码实现

```cpp
#include<bits/stdc++.h>

typedef long long ll;
typedef unsigned long long ull;

const int N = 3e2+10,M = N * N,INF = 0x3f3f3f3f,P = 998244353;


int main()
{
    std::ios::sync_with_stdio(false);
    int a,b,p;
    std::cin>>a>>b>>p;
    int res = 1;
    while(b)
    {
        if(b&1)res = (ll)res * a % p;
        b >>= 1;
        a = (ll)a * a % p;
    }
    std::cout<<res%p;
    return 0;
}
```
- **注意点**
>**1.中间计算过程会爆int，所以必须把其中一个数强制转换成long long参与运算**
>**2.在while循环外也要对最终结果res取模，避免出现b=0未取模的情况**
- 题目链接
[a^b](https://www.acwing.com/problem/content/91/)

