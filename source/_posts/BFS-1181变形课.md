---
title: BFS--1181变形课
date: 2022-04-14 13:05:14
tags:
categories:
mathjax: true
---
# 1181 变形课
![请添加图片描述](https://img-blog.csdnimg.cn/85e2719dda16447292e850c9840c067d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGltZXJfY2F0Y2g=,size_20,color_FFFFFF,t_70,g_se,x_16)



**题意：**
>![在这里插入图片描述](https://img-blog.csdnimg.cn/ffdc6c5ce7f7425f9392f09ba4adbe01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGltZXJfY2F0Y2g=,size_20,color_FFFFFF,t_70,g_se,x_16)
***
**思路：**
>把题目抽象成图，抽象方法如下:
>>起点：b
>终点：m
>路径：对于一个字符串$soon$，表示从$s$到$n$存在一条路径。
>根据如上规则建图bfs即可。

**AC代码：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/dd5ce80a17af455992d5087180e2de60.png)
```cpp
#include<bits/stdc++.h>

typedef long long ll;

const int N = 30,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;

int que[N];
bool g[N][N];
bool book[N];

bool bfs()
{
    memset(book,false,sizeof book);
    int head = 0,tail = -1;
    que[++tail] = 'b' - 'a';
    book['b' - 'a'] = true;
    while(tail>=head)
    {
        int temp = que[head++];
        if(temp=='m'-'a')return true;
        for(int i = 0 ; i < 26 ; i++)
        {
            if(!book[i] && g[temp][i])
            {
                que[++tail] = i;
                book[i] = true;
            }
        }
    }
    return false;
}

int main()
{
//    std::ios::sync_with_stdio(false);
//    std::cin.tie(nullptr);
//    std::cout.tie(nullptr);
    std::string s;
    while(std::cin>>s)
    {
        if(s[0]=='0') std::cout<<(bfs() ? "Yes.\n" : "No.\n"),memset(g,false,sizeof g);
        else g[s[0]-'a'][s[s.size()-1]-'a'] = true;
    }
    return 0;
}
```
