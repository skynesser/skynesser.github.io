---
title: 0x01位运算--64位整数乘法
date: 2022-04-14 12:58:43
tags:
categories:
- 算法进阶指南笔记
mathjax: true
---

## 0x01 位运算——64位整数乘法
![在这里插入图片描述](https://img-blog.csdnimg.cn/ab445f6ed60840cc9d5b2750f575a6d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGltZXJfY2F0Y2g=,size_20,color_FFFFFF,t_70,g_se,x_16)

- 问题简析
>C++内置的最高整数类型是64位，所以显然不能通过直接运算得到答案，我们需要一些特殊的处理方法，在这里提供两种方法。

1. 思路一

>类似于快速幂的思想，把b拆分成k位二进制。
>$b=C_{k-1}*2^{k-1}+C_{k-2}*2^{k-2}...+C_{0}*2^{0}。$
>$a*b=C_{k-1}*2^{k-1}*a+C_{k-2}*2^{k-2}*a...+C_{0}*2^{0}*a。$
>$若算出a*b^{i-1}mod~p，则计算(a*b^{i-1})*2mod~p的过程中不会超过2*10^{18}，long ~long可以胜任。$
- 时间复杂度分析
>$分解出的项数为k=\left \lceil log_{2}(b+1) \right \rceil$
>$时间复杂度:O log_{2}(n)$
- 代码实现

```cpp
#include<bits/stdc++.h>

typedef long long ll;
typedef unsigned long long ull;

const int N = 1e5+10,M = N,INF = 0x3f3f3f3f,P = 998244353;


int main()
{
    std::ios::sync_with_stdio(false);
    ll a,b,p;
    std::cin>>a>>b>>p;
    ll res = 0;
    for(; b ; b >>= 1)
    {
        if(b&1)res = (res + a)%p;
        a = a * 2 % p;
    }
    std::cout<<res;
    return 0;
}
```
2. 思路二
>$利用a*b ~mod~p=a*b-\left \lfloor a*b/p \right \rfloor*p，\left \lfloor  \right \rfloor为向下取整$
>$首先，假设a<p,b<p,那么a*b/p下取整之后一定也小于p，我们可以使用浮点数完成中间计算。$
>$long~double的浮点数有效数字在18$~$19位之间，可以胜任。$
>$a*b 和\left \lfloor a*b/p \right \rfloor*p可能会很大,但是易知它们的差值一定在0$~$p-1之间。$
>$因为p的范围在long~long以内，所以只需要关心a*b 和\left \lfloor a*b/p \right \rfloor*p在long~long范围内的位，更高的位一定是相同的。$

-  时间复杂度分析
>$O(1)$

- 代码实现

```cpp
#include<bits/stdc++.h>

typedef long long ll;
typedef unsigned long long ull;

const int N = 1e5+10,M = N,INF = 0x3f3f3f3f,P = 998244353;


int main()
{
    std::ios::sync_with_stdio(false);
    ll a,b,p;
    std::cin>>a>>b>>p;
    a %= p,b %= p;
    ll c = (long double)a * b / p;
    ll res = a * b - c * p;
    if(res < 0)res += p;
    else if(res >= p)res -= p;
    std::cout<<res;
    return 0;
}
```
- 注意点
1. 为什么a和b要mod p？
	因为我们需要保证$a*b/p$范围在long long内
2. 为什么用别的浮点数类型(double)会错？
	因为double的有效位数过小，在乘p以后导致错误
	例子：0.002 * 10000和0.0018 * 10000显然不同
	精度足够以后：
	0.0018 * 10000 和0.001811 * 10000不会影响
3. 为什么最后要有这一段代码？

```cpp
if(res < 0)res += p;
else if(res >= p)res -= p;
```
因为在第一行对a和b mod p后，由模的性质可以知道最后答案可能会与原来的答案产生p的差值。
- 题目：
[64位整数乘法](https://www.acwing.com/problem/content/92/)
