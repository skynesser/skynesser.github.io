---
title: 0x01位运算--起床困难综合症
date: 2022-04-14 13:00:21
tags:
categories:
mathjax: true
---
## 0x01位运算——起床困难综合症
![在这里插入图片描述](https://img-blog.csdnimg.cn/1a13dbceba85453aa07cf5bb185ed114.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGltZXJfY2F0Y2g=,size_20,color_FFFFFF,t_70,g_se,x_16)
- 思路分析
>位运算的特点之一就是二进制下运算不进位。因此在$x_{0}$可以任意选择的情况下，参与位运算的各个位(bit)是无关的。
><p>而每一个的初始取值只有0和1两种情况，所以我们只需要枚举每一位，比较初始取值0和1情况下，经过n个防御门后得到的值，在0和1这两种情况下取答案较大的即可。
</p>

> 同时,因为$x_{0}$的取值是有范围限制的，所以我们在最终大小相同的情况下，保证$x_{0}$尽可能小，即在初始值0和1经过n个防御们后得到值相同时，
> 我们会优先使用0。
- 时间复杂度
>$O(nlog_{2}(m))$
- 代码实现

```cpp
#include<bits/stdc++.h>

typedef long long ll;
typedef unsigned long long ull;

const int N = 1e5+10,M = N,INF = 0x3f3f3f3f,P = 998244353;

int n,x;
std::pair<std::string,int> PSI[N];

int cal(int bit,int val)
{
    for(int i = 1 ; i <= n ; i++)
    {
        int x = PSI[i].second>>bit & 1;
        if(PSI[i].first=="AND")val &= x;
        else if(PSI[i].first=="OR")val |= x;
        else val ^= x;
    }
    return val;
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin>>n>>x;
    for(int i = 1 ; i <= n ; i++)
    {
        std::cin>>PSI[i].first>>PSI[i].second;
    }
    int res = 0,val = 0;\\val表示最后的取值x，res表示最大值(答案)
    for(int bit = 29 ; bit >= 0 ; bit--)
    {
        int ans1 = cal(bit,1);
        int ans0 = cal(bit,0);
        if((1 << bit) + val <= x && ans0 < ans1)
            val += 1 << bit,res += 1 << bit;
        else
            res += ans0 << bit;
    }
    std::cout<<res;
    return 0;
}
```
- 题目：
[起床困难综合症](https://www.acwing.com/problem/content/1000/)
