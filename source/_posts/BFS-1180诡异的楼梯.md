---
title: BFS--1180诡异的楼梯
date: 2022-04-14 13:04:47
tags:
categories:
mathjax: true
---
# 1180诡异的楼梯
![请添加图片描述](https://img-blog.csdnimg.cn/690f7cf6ee0d4f47810586d775759365.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGltZXJfY2F0Y2g=,size_20,color_FFFFFF,t_70,g_se,x_16)


**题意：**
>中文题面，题意也比较直接，直接上原题。
![请添加图片描述](https://img-blog.csdnimg.cn/b1129ee048354d92954219b416999c67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdGltZXJfY2F0Y2g=,size_20,color_FFFFFF,t_70,g_se,x_16)
***
**思路：**
>在楼梯不能通过的时候，原地等待一个单位时间就可以了。
>>注：本题还有一种优先队列的做法，我们可以认为通过一个当前无法通过的楼梯，所花费的时间是2个单位时间(加上等待的时间)，但是这样做会使得队列中每次出队的不一定是步数最小的点，所以要用优先队列维护(其实没什么必要这样做，正常的bfs就可以解决)。

**AC代码：**
1. 不使用优先队列：
![在这里插入图片描述](https://img-blog.csdnimg.cn/cc79723eb7864a8e9ef2619a5a95b59b.png)

```cpp
#include<bits/stdc++.h>

typedef long long ll;

const int N = 30,M = 2e4+10,INF = 0x3f3f3f3f,mod = 1e9+7;
struct Node{
    int x,y,step;
}que[N*N*2];
char a[N][N];
bool book[N][N];
int n,m,start_x,start_y,end_x,end_y;
int ne[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};

bool OK(int x,int y)
{
    if(x<1||y<1||x>n||y>m||a[x][y]=='*'||book[x][y])return false;
    return true;
}

int bfs()
{
    memset(book,false,sizeof book);
    int head = 0,tail = -1;
    que[++tail] = {start_x,start_y,0};
    book[start_x][start_y] = true;
    while(tail>=head)
    {
        auto temp = que[head++];
        if(temp.x == end_x && temp.y == end_y)return temp.step;
        for(int i = 0 ; i < 4 ; i++)
        {
            int tx = temp.x + ne[i][0];
            int ty = temp.y + ne[i][1];
            if(!OK(tx,ty))continue;
            if(a[tx][ty]=='.'||a[tx][ty]=='T')book[tx][ty] = true,que[++tail] = {tx,ty,temp.step+1};
            else
            {
                if(a[tx][ty]=='|' && temp.step%2==0 || a[tx][ty]=='-' && temp.step%2==1)
                {
                    if(i < 2)//i < 2 表示上下移动
                    {
                        tx += ne[i][0];
                        if(OK(tx,ty))book[tx][ty] = true,que[++tail] = {tx,ty,temp.step+1};
                    }
                    else  que[++tail] = {temp.x,temp.y,temp.step+1};
                }
                else
                {
                    if(i >= 2)
                    {
                        ty += ne[i][1];
                        if(OK(tx,ty))book[tx][ty] = true,que[++tail] = {tx,ty,temp.step+1};
                    }
                    else que[++tail] = {temp.x,temp.y,temp.step+1};
                }
            }
        }
    }
    return -1;
}

int main()
{
//    std::ios::sync_with_stdio(false);
//    std::cin.tie(nullptr);
//    std::cout.tie(nullptr);
    while(std::cin>>n>>m)
    {
        for(int i = 1 ; i <= n ; i++)
            for(int j = 1 ; j <= m ; j++)
            {
                std::cin>>a[i][j];
                if(a[i][j]=='S')start_x = i,start_y = j;
                else if(a[i][j]=='T')end_x = i,end_y = j;
            }
        std::cout<<bfs()<<'\n';
    }
    return 0;
}
```

2. 使用优先队列
![在这里插入图片描述](https://img-blog.csdnimg.cn/841a376dda274038a92ffdcb51188205.png)

```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>
#include<cstring>
#include<queue>
#define rep(i,n) for(int i = 1 ; i <= n ; i++)
#define endl '\n'
using namespace std;
const int MAXN = 30;
typedef long long ll;
struct node{
    int x,y,step;
    friend bool operator <(struct node x,struct node y)
    {
        return x.step>y.step;
    }
};



priority_queue<struct node> que;
char g[MAXN][MAXN];
bool book[MAXN][MAXN];
int head,tail,n,m;
int startx,starty,endx,endy;
int ne[4][2] = {0,1,1,0,0,-1,-1,0};

int bfs()
{
    rep(i,n)
    rep(j,m)
    book[i][j] = false;
    head = tail = 0;
    book[startx][starty] = true;
    que.push({startx,starty,0});
    while(tail>=head)
    {
        auto temp = que.top();
        que.pop();
//        cout<<temp.x<<" "<<temp.y<<" "<<temp.step<<endl;
        if(temp.x==endx&&temp.y==endy)
            return temp.step;
        for(int i = 0 ; i < 4 ; i++)
        {
            int tx = temp.x+ne[i][0];
            int ty = temp.y+ne[i][1];
            if(tx<1||ty<1||tx>n||ty>m||book[tx][ty]||g[tx][ty]=='*')continue;
            if(g[tx][ty]=='|'&&!(temp.step&1)||g[tx][ty]=='-'&&temp.step&1)//奇数上下
            {
                if(i&1)
                {
                    tx+=ne[i][0];
                    ty+=ne[i][1];
                    if(book[tx][ty])continue;
                    book[tx][ty] = true;
                    que.push({tx,ty,temp.step+1});
                }
                else
                {
                    tx+=ne[i][0];
                    ty+=ne[i][1];
                    if(book[tx][ty])continue;
                    book[tx][ty] = true;
                    que.push({tx,ty,temp.step+2});
                }
            }
            else if(g[tx][ty]=='|'&&temp.step&1||g[tx][ty]=='-'&&!(temp.step&1))
            {
                if(i&1)
                {
                    tx+=ne[i][0];
                    ty+=ne[i][1];
                    if(book[tx][ty])continue;
                    book[tx][ty] = true;
                    que.push({tx,ty,temp.step+2});
                }
                else
                {
                    tx+=ne[i][0];
                    ty+=ne[i][1];
                    if(book[tx][ty])continue;
                    book[tx][ty] = true;
                    que.push({tx,ty,temp.step+1});
                }
            }
            else
            {
                if(book[tx][ty])continue;
                book[tx][ty] = true;
                que.push({tx,ty,temp.step+1});
            }
        }
    }
    return -1;
}

int main()
{
    ios::sync_with_stdio(false);
//    cin.tie(0);
//    cout.tie(0);
    while(cin>>n>>m)
    {
        rep(i,n)
        rep(j,m)
        {
            cin >> g[i][j];
            if(g[i][j]=='S')
            {
                startx = i;
                starty = j;
            }
            if(g[i][j]=='T')
            {
                endx = i;
                endy = j;
            }
        }
        cout << bfs()<<endl;
    }
    return 0;
}
```
